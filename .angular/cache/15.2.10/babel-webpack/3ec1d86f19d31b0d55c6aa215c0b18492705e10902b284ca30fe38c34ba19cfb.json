{"ast":null,"code":"import _asyncToGenerator from \"/Users/ricardoda-silva/Desktop/Project/RiAn/AnRi v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst DEFAULT_RETRY_ATTEMPTS = 3;\n/**\n * Retry middleware\n */\nconst retryMiddlewareFactory = ({\n  maxAttempts = DEFAULT_RETRY_ATTEMPTS,\n  retryDecider,\n  computeDelay,\n  abortSignal\n}) => {\n  if (maxAttempts < 1) {\n    throw new Error('maxAttempts must be greater than 0');\n  }\n  return (next, context) => /*#__PURE__*/function () {\n    var _retryMiddleware = _asyncToGenerator(function* (request) {\n      let error;\n      let attemptsCount = context.attemptsCount ?? 0;\n      let response;\n      // When retry is not needed or max attempts is reached, either error or response will be set. This function handles either cases.\n      const handleTerminalErrorOrResponse = () => {\n        if (response) {\n          addOrIncrementMetadataAttempts(response, attemptsCount);\n          return response;\n        } else {\n          addOrIncrementMetadataAttempts(error, attemptsCount);\n          throw error;\n        }\n      };\n      while (!abortSignal?.aborted && attemptsCount < maxAttempts) {\n        try {\n          response = yield next(request);\n          error = undefined;\n        } catch (e) {\n          error = e;\n          response = undefined;\n        }\n        // context.attemptsCount may be updated after calling next handler which may retry the request by itself.\n        attemptsCount = (context.attemptsCount ?? 0) > attemptsCount ? context.attemptsCount ?? 0 : attemptsCount + 1;\n        context.attemptsCount = attemptsCount;\n        if (yield retryDecider(response, error)) {\n          if (!abortSignal?.aborted && attemptsCount < maxAttempts) {\n            // prevent sleep for last attempt or cancelled request;\n            const delay = computeDelay(attemptsCount);\n            yield cancellableSleep(delay, abortSignal);\n          }\n          continue;\n        } else {\n          return handleTerminalErrorOrResponse();\n        }\n      }\n      if (abortSignal?.aborted) {\n        throw new Error('Request aborted.');\n      } else {\n        return handleTerminalErrorOrResponse();\n      }\n    });\n    function retryMiddleware(_x) {\n      return _retryMiddleware.apply(this, arguments);\n    }\n    return retryMiddleware;\n  }();\n};\nconst cancellableSleep = (timeoutMs, abortSignal) => {\n  if (abortSignal?.aborted) {\n    return Promise.resolve();\n  }\n  let timeoutId;\n  let sleepPromiseResolveFn;\n  const sleepPromise = new Promise(resolve => {\n    sleepPromiseResolveFn = resolve;\n    timeoutId = setTimeout(resolve, timeoutMs);\n  });\n  abortSignal?.addEventListener('abort', function cancelSleep(_) {\n    clearTimeout(timeoutId);\n    abortSignal?.removeEventListener('abort', cancelSleep);\n    sleepPromiseResolveFn();\n  });\n  return sleepPromise;\n};\nconst addOrIncrementMetadataAttempts = (nextHandlerOutput, attempts) => {\n  if (Object.prototype.toString.call(nextHandlerOutput) !== '[object Object]') {\n    return;\n  }\n  nextHandlerOutput.$metadata = {\n    ...(nextHandlerOutput.$metadata ?? {}),\n    attempts\n  };\n};\nexport { retryMiddlewareFactory };\n//# sourceMappingURL=middleware.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}