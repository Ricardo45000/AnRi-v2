{"ast":null,"code":"import _asyncToGenerator from \"/Users/ricardoda-silva/Desktop/Project/RiAn/AnRi v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BackgroundManagerNotOpenError } from './BackgroundManagerNotOpenError.mjs';\nimport { BackgroundProcessManagerState } from './types.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * @private For internal Amplify use.\n *\n * Creates a new scope for promises, observables, and other types of work or\n * processes that may be running in the background. This manager provides\n * an singular entrypoint to request termination and await completion.\n *\n * As work completes on its own prior to close, the manager removes them\n * from the registry to avoid holding references to completed jobs.\n */\nclass BackgroundProcessManager {\n  constructor() {\n    /**\n     * A string indicating whether the manager is accepting new work (\"Open\"),\n     * waiting for work to complete (\"Closing\"), or fully done with all\n     * submitted work and *not* accepting new jobs (\"Closed\").\n     */\n    this._state = BackgroundProcessManagerState.Open;\n    /**\n     * The list of outstanding jobs we'll need to wait for upon `close()`\n     */\n    this.jobs = new Set();\n  }\n  add(jobOrDescription, optionalDescription) {\n    let job;\n    let description;\n    if (typeof jobOrDescription === 'string') {\n      job = undefined;\n      description = jobOrDescription;\n    } else {\n      job = jobOrDescription;\n      description = optionalDescription;\n    }\n    const error = this.closedFailure(description);\n    if (error) return error;\n    if (job === undefined) {\n      return this.addHook(description);\n    } else if (typeof job === 'function') {\n      return this.addFunction(job, description);\n    } else if (job instanceof BackgroundProcessManager) {\n      this.addManager(job, description);\n    } else {\n      throw new Error('If `job` is provided, it must be an Observable, Function, or BackgroundProcessManager.');\n    }\n  }\n  /**\n   * Adds a **cleaner** function that doesn't immediately get executed.\n   * Instead, the caller gets a **terminate** function back. The *cleaner* is\n   * invoked only once the mananger *closes* or the returned **terminate**\n   * function is called.\n   *\n   * @param clean The cleanup function.\n   * @param description Optional description to help identify pending jobs.\n   * @returns A terminate function.\n   */\n  addCleaner(clean, description) {\n    const {\n      resolve,\n      onTerminate\n    } = this.addHook(description);\n    const proxy = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        yield clean();\n        resolve();\n      });\n      return function proxy() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    onTerminate.then(proxy);\n    return proxy;\n  }\n  addFunction(job, description) {\n    // the function we call when we want to try to terminate this job.\n    let terminate;\n    // the promise the job can opt into listening to for termination.\n    const onTerminate = new Promise(resolve => {\n      terminate = resolve;\n    });\n    // finally! start the job.\n    const jobResult = job(onTerminate);\n    // depending on what the job gives back, register the result\n    // so we can monitor for completion.\n    if (typeof jobResult?.then === 'function') {\n      this.registerPromise(jobResult, terminate, description);\n    }\n    // At the end of the day, or you know, method call, it doesn't matter\n    // what the return value is at all; we just pass it through to the\n    // caller.\n    return jobResult;\n  }\n  addManager(manager, description) {\n    this.addCleaner( /*#__PURE__*/_asyncToGenerator(function* () {\n      return manager.close();\n    }), description);\n  }\n  /**\n   * Creates and registers a fabricated job for processes that need to operate\n   * with callbacks/hooks. The returned `resolve` and `reject`\n   * functions can be used to signal the job is done successfully or not.\n   * The returned `onTerminate` is a promise that will resolve when the\n   * manager is requesting the termination of the job.\n   *\n   * @param description Optional description to help identify pending jobs.\n   * @returns `{ resolve, reject, onTerminate }`\n   */\n  addHook(description) {\n    // the resolve/reject functions we'll provide to the caller to signal\n    // the state of the job.\n    let promiseResolve;\n    let promiseReject;\n    // the underlying promise we'll use to manage it, pretty much like\n    // any other promise.\n    const promise = new Promise((resolve, reject) => {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n    // the function we call when we want to try to terminate this job.\n    let terminate;\n    // the promise the job can opt into listening to for termination.\n    const onTerminate = new Promise(resolve => {\n      terminate = resolve;\n    });\n    this.registerPromise(promise, terminate, description);\n    return {\n      resolve: promiseResolve,\n      reject: promiseReject,\n      onTerminate\n    };\n  }\n  /**\n   * Adds a Promise based job to the list of jobs for monitoring and listens\n   * for either a success or failure, upon which the job is considered \"done\"\n   * and removed from the registry.\n   *\n   * @param promise A promise that is on its way to being returned to a\n   * caller, which needs to be tracked as a background job.\n   * @param terminate The termination function to register, which can be\n   * invoked to request the job stop.\n   * @param description Optional description to help identify pending jobs.\n   */\n  registerPromise(promise, terminate, description) {\n    const jobEntry = {\n      promise,\n      terminate,\n      description\n    };\n    this.jobs.add(jobEntry);\n    // in all of my testing, it is safe to multi-subscribe to a promise.\n    // so, rather than create another layer of promising, we're just going\n    // to hook into the promise we already have, and when it's done\n    // (successfully or not), we no longer need to wait for it upon close.\n    //\n    // sorry this is a bit hand-wavy:\n    //\n    // i believe we use `.then` and `.catch` instead of `.finally` because\n    // `.finally` is invoked in a different order in the sequence, and this\n    // breaks assumptions throughout and causes failures.\n    promise.then(() => {\n      this.jobs.delete(jobEntry);\n    }).catch(() => {\n      this.jobs.delete(jobEntry);\n    });\n  }\n  /**\n   * The number of jobs being waited on.\n   *\n   * We don't use this for anything. It's just informational for the caller,\n   * and can be used in logging and testing.\n   *\n   * @returns the number of jobs.\n   */\n  get length() {\n    return this.jobs.size;\n  }\n  /**\n   * The execution state of the manager. One of:\n   *\n   * 1. \"Open\" -> Accepting new jobs\n   * 1. \"Closing\" -> Not accepting new work. Waiting for jobs to complete.\n   * 1. \"Closed\" -> Not accepting new work. All submitted jobs are complete.\n   */\n  get state() {\n    return this._state;\n  }\n  /**\n   * The registered `description` of all still-pending jobs.\n   *\n   * @returns descriptions as an array.\n   */\n  get pending() {\n    return Array.from(this.jobs).map(job => job.description);\n  }\n  /**\n   * Whether the manager is accepting new jobs.\n   */\n  get isOpen() {\n    return this._state === BackgroundProcessManagerState.Open;\n  }\n  /**\n   * Whether the manager is rejecting new work, but still waiting for\n   * submitted work to complete.\n   */\n  get isClosing() {\n    return this._state === BackgroundProcessManagerState.Closing;\n  }\n  /**\n   * Whether the manager is rejecting work and done waiting for submitted\n   * work to complete.\n   */\n  get isClosed() {\n    return this._state === BackgroundProcessManagerState.Closed;\n  }\n  closedFailure(description) {\n    if (!this.isOpen) {\n      return Promise.reject(new BackgroundManagerNotOpenError([`The manager is ${this.state}.`, `You tried to add \"${description}\".`, `Pending jobs: [\\n${this.pending.map(t => '    ' + t).join(',\\n')}\\n]`].join('\\n')));\n    }\n  }\n  /**\n   * Signals jobs to stop (for those that accept interruptions) and waits\n   * for confirmation that jobs have stopped.\n   *\n   * This immediately puts the manager into a closing state and just begins\n   * to reject new work. After all work in the manager is complete, the\n   * manager goes into a `Completed` state and `close()` returns.\n   *\n   * This call is idempotent.\n   *\n   * If the manager is already closing or closed, `finalCleaup` is not executed.\n   *\n   * @param onClosed\n   * @returns The settled results of each still-running job's promise. If the\n   * manager is already closed, this will contain the results as of when the\n   * manager's `close()` was called in an `Open` state.\n   */\n  close() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.isOpen) {\n        _this._state = BackgroundProcessManagerState.Closing;\n        for (const job of Array.from(_this.jobs)) {\n          try {\n            job.terminate();\n          } catch (error) {\n            // Due to potential races with a job's natural completion, it's\n            // reasonable to expect the termination call to fail. Hence,\n            // not logging as an error.\n            console.warn(`Failed to send termination signal to job. Error: ${error.message}`, job);\n          }\n        }\n        // Use `allSettled()` because we want to wait for all to finish. We do\n        // not want to stop waiting if there is a failure.\n        _this._closingPromise = Promise.allSettled(Array.from(_this.jobs).map(j => j.promise));\n        yield _this._closingPromise;\n        _this._state = BackgroundProcessManagerState.Closed;\n      }\n      return _this._closingPromise;\n    })();\n  }\n  /**\n   * Signals the manager to start accepting work (again) and returns once\n   * the manager is ready to do so.\n   *\n   * If the state is already `Open`, this call is a no-op.\n   *\n   * If the state is `Closed`, this call simply updates state and returns.\n   *\n   * If the state is `Closing`, this call waits for completion before it\n   * updates the state and returns.\n   */\n  open() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.isClosing) {\n        yield _this2.close();\n      }\n      _this2._state = BackgroundProcessManagerState.Open;\n    })();\n  }\n}\nexport { BackgroundProcessManager };\n//# sourceMappingURL=BackgroundProcessManager.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}