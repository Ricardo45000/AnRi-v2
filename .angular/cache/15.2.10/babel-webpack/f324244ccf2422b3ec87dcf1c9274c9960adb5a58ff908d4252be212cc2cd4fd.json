{"ast":null,"code":"import _asyncToGenerator from \"/Users/ricardoda-silva/Desktop/Project/RiAn/AnRi v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ConsoleLogger } from '../../../Logger/ConsoleLogger.mjs';\nimport '../../../utils/getClientInfo/getClientInfo.mjs';\nimport '../../../utils/retry/retry.mjs';\nimport '@aws-crypto/sha256-js';\nimport '@smithy/util-hex-encoding';\nimport '../../../awsClients/pinpoint/base.mjs';\nimport { putEvents } from '../../../awsClients/pinpoint/putEvents.mjs';\nimport { isAppInForeground } from './isAppInForeground.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('PinpointEventBuffer');\nconst RETRYABLE_CODES = [429, 500];\nconst ACCEPTED_CODES = [202];\nclass PinpointEventBuffer {\n  constructor(config) {\n    this._interval = undefined;\n    this._pause = false;\n    this._flush = false;\n    this._buffer = [];\n    this._config = config;\n    this._sendBatch = this._sendBatch.bind(this);\n    this._startLoop();\n  }\n  push(event) {\n    if (this._buffer.length >= this._config.bufferSize) {\n      logger.debug('Exceeded Pinpoint event buffer limits, event dropped.', {\n        eventId: event.eventId\n      });\n      return;\n    }\n    this._buffer.push({\n      [event.eventId]: event\n    });\n  }\n  pause() {\n    this._pause = true;\n  }\n  resume() {\n    this._pause = false;\n  }\n  flush() {\n    this._flush = true;\n  }\n  identityHasChanged(identityId) {\n    return this._config.identityId !== identityId;\n  }\n  flushAll() {\n    this._putEvents(this._buffer.splice(0, this._buffer.length));\n  }\n  _startLoop() {\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n    const {\n      flushInterval\n    } = this._config;\n    this._interval = setInterval(this._sendBatch, flushInterval);\n  }\n  _sendBatch() {\n    const bufferLength = this._buffer.length;\n    if (this._flush && !bufferLength && this._interval) {\n      clearInterval(this._interval);\n    }\n    if (this._pause || !bufferLength || !isAppInForeground()) {\n      return;\n    }\n    const {\n      flushSize\n    } = this._config;\n    const batchSize = Math.min(flushSize, bufferLength);\n    const bufferSubset = this._buffer.splice(0, batchSize);\n    this._putEvents(bufferSubset);\n  }\n  _putEvents(buffer) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const eventMap = _this._bufferToMap(buffer);\n      const batchEventParams = _this._generateBatchEventParams(eventMap);\n      try {\n        const {\n          credentials,\n          region,\n          userAgentValue\n        } = _this._config;\n        const data = yield putEvents({\n          credentials,\n          region,\n          userAgentValue\n        }, batchEventParams);\n        _this._processPutEventsSuccessResponse(data, eventMap);\n      } catch (err) {\n        _this._handlePutEventsFailure(err, eventMap);\n      }\n    })();\n  }\n  _generateBatchEventParams(eventMap) {\n    const batchItem = {};\n    Object.values(eventMap).forEach(item => {\n      const {\n        event,\n        timestamp,\n        endpointId,\n        eventId,\n        session\n      } = item;\n      const {\n        name,\n        attributes,\n        metrics\n      } = event;\n      batchItem[endpointId] = {\n        Endpoint: {\n          ...batchItem[endpointId]?.Endpoint\n        },\n        Events: {\n          ...batchItem[endpointId]?.Events,\n          [eventId]: {\n            EventType: name,\n            Timestamp: new Date(timestamp).toISOString(),\n            Attributes: attributes,\n            Metrics: metrics,\n            Session: session\n          }\n        }\n      };\n    });\n    return {\n      ApplicationId: this._config.appId,\n      EventsRequest: {\n        BatchItem: batchItem\n      }\n    };\n  }\n  _handlePutEventsFailure(err, eventMap) {\n    logger.debug('putEvents call to Pinpoint failed.', err);\n    const statusCode = err.$metadata && err.$metadata.httpStatusCode;\n    if (RETRYABLE_CODES.includes(statusCode)) {\n      const retryableEvents = Object.values(eventMap);\n      this._retry(retryableEvents);\n    }\n  }\n  _processPutEventsSuccessResponse(data, eventMap) {\n    const {\n      Results = {}\n    } = data.EventsResponse ?? {};\n    const retryableEvents = [];\n    Object.entries(Results).forEach(([_, endpointValues]) => {\n      const responses = endpointValues.EventsItemResponse ?? {};\n      Object.entries(responses).forEach(([eventId, eventValues]) => {\n        const eventObject = eventMap[eventId];\n        if (!eventObject) {\n          return;\n        }\n        const {\n          StatusCode,\n          Message\n        } = eventValues ?? {};\n        if (StatusCode && ACCEPTED_CODES.includes(StatusCode)) {\n          return;\n        }\n        if (StatusCode && RETRYABLE_CODES.includes(StatusCode)) {\n          retryableEvents.push(eventObject);\n          return;\n        }\n        const {\n          name\n        } = eventObject.event;\n        logger.warn('Pinpoint event failed to send.', {\n          eventId,\n          name,\n          message: Message\n        });\n      });\n    });\n    if (retryableEvents.length) {\n      this._retry(retryableEvents);\n    }\n  }\n  _retry(retryableEvents) {\n    // retryable events that haven't reached the resendLimit\n    const eligibleEvents = [];\n    retryableEvents.forEach(bufferedEvent => {\n      const {\n        eventId\n      } = bufferedEvent;\n      const {\n        name\n      } = bufferedEvent.event;\n      if (bufferedEvent.resendLimit-- > 0) {\n        logger.debug('Resending event.', {\n          eventId,\n          name,\n          remainingAttempts: bufferedEvent.resendLimit\n        });\n        eligibleEvents.push({\n          [eventId]: bufferedEvent\n        });\n        return;\n      }\n      logger.debug('No retry attempts remaining for event.', {\n        eventId,\n        name\n      });\n    });\n    // add the events to the front of the buffer\n    this._buffer.unshift(...eligibleEvents);\n  }\n  _bufferToMap(buffer) {\n    return buffer.reduce((acc, curVal) => {\n      const [[key, value]] = Object.entries(curVal);\n      acc[key] = value;\n      return acc;\n    }, {});\n  }\n}\nexport { PinpointEventBuffer };\n//# sourceMappingURL=PinpointEventBuffer.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}