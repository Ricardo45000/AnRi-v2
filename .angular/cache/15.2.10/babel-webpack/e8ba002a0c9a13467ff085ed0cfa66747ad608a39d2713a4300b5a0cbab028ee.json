{"ast":null,"code":"import _asyncToGenerator from \"/Users/ricardoda-silva/Desktop/Project/RiAn/AnRi v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ConsoleLogger } from '../../Logger/ConsoleLogger.mjs';\nimport { isNonRetryableError } from './isNonRetryableError.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('retryUtil');\n/**\n * @private\n * Internal use of Amplify only\n */\nfunction retry(_x, _x2, _x3, _x4) {\n  return _retry.apply(this, arguments);\n}\nfunction _retry() {\n  _retry = _asyncToGenerator(function* (functionToRetry, args, delayFn, onTerminate) {\n    if (typeof functionToRetry !== 'function') {\n      throw Error('functionToRetry must be a function');\n    }\n    // TODO(eslint): remove this linter suppression with refactoring.\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (resolve, reject) {\n        let attempt = 0;\n        let terminated = false;\n        let timeout;\n        let wakeUp = () => {\n          // no-op\n        }; // will be replaced with a resolver()\n        // used after the loop if terminated while waiting for a timer.\n        let lastError;\n        onTerminate && onTerminate.then(() => {\n          // signal not to try anymore.\n          terminated = true;\n          // stop sleeping if we're sleeping.\n          clearTimeout(timeout);\n          wakeUp();\n        });\n        // TODO(eslint): remove this linter suppression with refactoring.\n        // eslint-disable-next-line no-unmodified-loop-condition\n        while (!terminated) {\n          attempt++;\n          logger.debug(`${functionToRetry.name} attempt #${attempt} with this vars: ${JSON.stringify(args)}`);\n          try {\n            resolve(yield functionToRetry(...args));\n            return;\n          } catch (err) {\n            lastError = err;\n            logger.debug(`error on ${functionToRetry.name}`, err);\n            if (isNonRetryableError(err)) {\n              logger.debug(`${functionToRetry.name} non retryable error`, err);\n              reject(err);\n              return;\n            }\n            const retryIn = delayFn(attempt, args, err);\n            logger.debug(`${functionToRetry.name} retrying in ${retryIn} ms`);\n            // we check `terminated` again here because it could have flipped\n            // in the time it took `functionToRetry` to return.\n            if (retryIn === false || terminated) {\n              reject(err);\n              return;\n            } else {\n              yield new Promise(_resolve => {\n                wakeUp = _resolve; // export wakeUp for onTerminate handling\n                timeout = setTimeout(wakeUp, retryIn);\n              });\n            }\n          }\n        }\n        // reached if terminated while waiting for a timer.\n        reject(lastError);\n      });\n      return function (_x5, _x6) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  });\n  return _retry.apply(this, arguments);\n}\nexport { retry };\n//# sourceMappingURL=retry.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}