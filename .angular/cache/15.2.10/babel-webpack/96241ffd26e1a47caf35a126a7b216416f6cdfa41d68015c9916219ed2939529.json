{"ast":null,"code":"import { signRequest } from '../clients/middleware/signing/signer/signatureV4/signRequest.mjs';\nimport { presignUrl } from '../clients/middleware/signing/signer/signatureV4/presignUrl.mjs';\nimport { TOKEN_QUERY_PARAM } from '../clients/middleware/signing/signer/signatureV4/constants.mjs';\nimport '@aws-crypto/sha256-js';\nimport '@smithy/util-hex-encoding';\nimport { AmplifyUrl } from '../utils/amplifyUrl/index.mjs';\nimport { DateUtils } from './DateUtils.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst IOT_SERVICE_NAME = 'iotdevicegateway';\n// Best practice regex to parse the service and region from an AWS endpoint\nconst AWS_ENDPOINT_REGEX = /([^.]+)\\.(?:([^.]*)\\.)?amazonaws\\.com(.cn)?$/;\n/**\n * This class is intended to be deprecated and replaced by `signRequest` and `presignUrl` functions from\n * `clients/middleware/signing/signer/signatureV4`.\n *\n * TODO: refactor the logics here into `signRequest` and `presignUrl` functions and remove this class.\n *\n * @internal\n * @deprecated\n */\nclass Signer {\n  /**\n  * Sign a HTTP request, add 'Authorization' header to request param\n  * @method sign\n  * @memberof Signer\n  * @static\n  *\n  * @param {object} request - HTTP request object\n  <pre>\n  request: {\n      method: GET | POST | PUT ...\n      url: ...,\n      headers: {\n          header1: ...\n      },\n      data: data\n  }\n  </pre>\n  * @param {object} access_info - AWS access credential info\n  <pre>\n  access_info: {\n      access_key: ...,\n      secret_key: ...,\n      session_token: ...\n  }\n  </pre>\n  * @param {object} [service_info] - AWS service type and region, optional,\n  *                                  if not provided then parse out from url\n  <pre>\n  service_info: {\n      service: ...,\n      region: ...\n  }\n  </pre>\n  *\n  * @returns {object} Signed HTTP request\n  */\n  static sign(request, accessInfo, serviceInfo) {\n    request.headers = request.headers || {};\n    if (request.body && !request.data) {\n      throw new Error('The attribute \"body\" was found on the request object. Please use the attribute \"data\" instead.');\n    }\n    const requestToSign = {\n      ...request,\n      body: request.data,\n      url: new AmplifyUrl(request.url)\n    };\n    const options = getOptions(requestToSign, accessInfo, serviceInfo);\n    const signedRequest = signRequest(requestToSign, options);\n    // Prior to using `signRequest`, Signer accepted urls as strings and outputted urls as string. Coerce the property\n    // back to a string so as not to disrupt consumers of Signer.\n    signedRequest.url = signedRequest.url.toString();\n    // HTTP headers should be case insensitive but, to maintain parity with the previous Signer implementation and\n    // limit the impact of this implementation swap, replace lowercased headers with title cased ones.\n    signedRequest.headers.Authorization = signedRequest.headers.authorization;\n    signedRequest.headers['X-Amz-Security-Token'] = signedRequest.headers['x-amz-security-token'];\n    delete signedRequest.headers.authorization;\n    delete signedRequest.headers['x-amz-security-token'];\n    return signedRequest;\n  }\n  static signUrl(urlOrRequest, accessInfo, serviceInfo, expiration) {\n    const urlToSign = typeof urlOrRequest === 'object' ? urlOrRequest.url : urlOrRequest;\n    const method = typeof urlOrRequest === 'object' ? urlOrRequest.method : 'GET';\n    const body = typeof urlOrRequest === 'object' ? urlOrRequest.body : undefined;\n    const presignable = {\n      body,\n      method,\n      url: new AmplifyUrl(urlToSign)\n    };\n    const options = getOptions(presignable, accessInfo, serviceInfo, expiration);\n    const signedUrl = presignUrl(presignable, options);\n    if (accessInfo.session_token && !sessionTokenRequiredInSigning(options.signingService)) {\n      signedUrl.searchParams.append(TOKEN_QUERY_PARAM, accessInfo.session_token);\n    }\n    return signedUrl.toString();\n  }\n}\nconst getOptions = (request, accessInfo, serviceInfo, expiration) => {\n  const {\n    access_key,\n    secret_key,\n    session_token\n  } = accessInfo ?? {};\n  const {\n    region: urlRegion,\n    service: urlService\n  } = parseServiceInfo(request.url);\n  const {\n    region = urlRegion,\n    service = urlService\n  } = serviceInfo ?? {};\n  const credentials = {\n    accessKeyId: access_key,\n    secretAccessKey: secret_key,\n    ...(sessionTokenRequiredInSigning(service) ? {\n      sessionToken: session_token\n    } : {})\n  };\n  return {\n    credentials,\n    signingDate: DateUtils.getDateWithClockOffset(),\n    signingRegion: region,\n    signingService: service,\n    ...(expiration && {\n      expiration\n    })\n  };\n};\nconst parseServiceInfo = url => {\n  const {\n    host\n  } = url;\n  const matched = host.match(AWS_ENDPOINT_REGEX) ?? [];\n  let parsed = matched.slice(1, 3);\n  if (parsed[1] === 'es') {\n    // Elastic Search\n    parsed = parsed.reverse();\n  }\n  return {\n    service: parsed[0],\n    region: parsed[1]\n  };\n};\n// IoT service does not allow the session token in the canonical request\n// https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\nconst sessionTokenRequiredInSigning = service => service !== IOT_SERVICE_NAME;\nexport { Signer };\n//# sourceMappingURL=Signer.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}