{"ast":null,"code":"import _asyncToGenerator from \"/Users/ricardoda-silva/Desktop/Project/RiAn/AnRi v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ConsoleLogger } from '../Logger/ConsoleLogger.mjs';\nimport { defaultConfig, currentSizeKey } from './constants.mjs';\nimport { getCurrentSizeKey, getCurrentTime, getByteLength } from './utils/cacheHelpers.mjs';\nimport { assert, CacheErrorCode } from './utils/errorHelpers.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('StorageCache');\n/**\n * Initialization of the cache\n *\n */\nclass StorageCacheCommon {\n  /**\n   * Initialize the cache\n   *\n   * @param config - Custom configuration for this instance.\n   */\n  constructor({\n    config,\n    keyValueStorage\n  }) {\n    this.config = {\n      ...defaultConfig,\n      ...config\n    };\n    this.keyValueStorage = keyValueStorage;\n    this.sanitizeConfig();\n  }\n  getModuleName() {\n    return 'Cache';\n  }\n  /**\n   * Set custom configuration for the cache instance.\n   *\n   * @param config - customized configuration (without keyPrefix, which can't be changed)\n   *\n   * @return - the current configuration\n   */\n  configure(config) {\n    if (config) {\n      if (config.keyPrefix) {\n        logger.warn('keyPrefix can not be re-configured on an existing Cache instance.');\n      }\n      this.config = {\n        ...this.config,\n        ...config\n      };\n    }\n    this.sanitizeConfig();\n    return this.config;\n  }\n  /**\n   * return the current size of the cache\n   * @return {Promise}\n   */\n  getCurrentCacheSize() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let size = yield _this.getStorage().getItem(getCurrentSizeKey(_this.config.keyPrefix));\n      if (!size) {\n        yield _this.getStorage().setItem(getCurrentSizeKey(_this.config.keyPrefix), '0');\n        size = '0';\n      }\n      return Number(size);\n    })();\n  }\n  /**\n   * Set item into cache. You can put number, string, boolean or object.\n   * The cache will first check whether has the same key.\n   * If it has, it will delete the old item and then put the new item in\n   * The cache will pop out items if it is full\n   * You can specify the cache item options. The cache will abort and output a warning:\n   * If the key is invalid\n   * If the size of the item exceeds itemMaxSize.\n   * If the value is undefined\n   * If incorrect cache item configuration\n   * If error happened with browser storage\n   *\n   * @param {String} key - the key of the item\n   * @param {Object} value - the value of the item\n   * @param {Object} [options] - optional, the specified meta-data\n   *\n   * @return {Promise}\n   */\n  setItem(key, value, options) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      logger.debug(`Set item: key is ${key}, value is ${value} with options: ${options}`);\n      if (!key || key === currentSizeKey) {\n        logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n        return;\n      }\n      if (typeof value === 'undefined') {\n        logger.warn(`The value of item should not be undefined!`);\n        return;\n      }\n      const cacheItemOptions = {\n        priority: options?.priority !== undefined ? options.priority : _this2.config.defaultPriority,\n        expires: options?.expires !== undefined ? options.expires : _this2.config.defaultTTL + getCurrentTime()\n      };\n      if (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\n        logger.warn(`Invalid parameter: priority due to out or range. It should be within 1 and 5.`);\n        return;\n      }\n      const prefixedKey = `${_this2.config.keyPrefix}${key}`;\n      const item = _this2.fillCacheItem(prefixedKey, value, cacheItemOptions);\n      // check whether this item is too big;\n      if (item.byteSize > _this2.config.itemMaxSize) {\n        logger.warn(`Item with key: ${key} you are trying to put into is too big!`);\n        return;\n      }\n      try {\n        // first look into the storage, if it exists, delete it.\n        const val = yield _this2.getStorage().getItem(prefixedKey);\n        if (val) {\n          yield _this2.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n        }\n        // check whether the cache is full\n        if (yield _this2.isCacheFull(item.byteSize)) {\n          const validKeys = yield _this2.clearInvalidAndGetRemainingKeys();\n          if (yield _this2.isCacheFull(item.byteSize)) {\n            const sizeToPop = yield _this2.sizeToPop(item.byteSize);\n            yield _this2.popOutItems(validKeys, sizeToPop);\n          }\n        }\n        // put item in the cache\n        return _this2.setCacheItem(prefixedKey, item);\n      } catch (e) {\n        logger.warn(`setItem failed! ${e}`);\n      }\n    })();\n  }\n  /**\n   * Get item from cache. It will return null if item doesnâ€™t exist or it has been expired.\n   * If you specified callback function in the options,\n   * then the function will be executed if no such item in the cache\n   * and finally put the return value into cache.\n   * Please make sure the callback function will return the value you want to put into the cache.\n   * The cache will abort output a warning:\n   * If the key is invalid\n   * If error happened with AsyncStorage\n   *\n   * @param {String} key - the key of the item\n   * @param {Object} [options] - the options of callback function\n   *\n   * @return {Promise} - return a promise resolves to be the value of the item\n   */\n  getItem(key, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      logger.debug(`Get item: key is ${key} with options ${options}`);\n      let cached;\n      if (!key || key === currentSizeKey) {\n        logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n        return null;\n      }\n      const prefixedKey = `${_this3.config.keyPrefix}${key}`;\n      try {\n        cached = yield _this3.getStorage().getItem(prefixedKey);\n        if (cached != null) {\n          if (yield _this3.isExpired(prefixedKey)) {\n            // if expired, remove that item and return null\n            yield _this3.removeCacheItem(prefixedKey, JSON.parse(cached).byteSize);\n          } else {\n            // if not expired, update its visitedTime and return the value\n            const item = yield _this3.updateVisitedTime(JSON.parse(cached), prefixedKey);\n            return item.data;\n          }\n        }\n        if (options?.callback) {\n          const val = options.callback();\n          if (val !== null) {\n            yield _this3.setItem(key, val, options);\n          }\n          return val;\n        }\n        return null;\n      } catch (e) {\n        logger.warn(`getItem failed! ${e}`);\n        return null;\n      }\n    })();\n  }\n  /**\n   * remove item from the cache\n   * The cache will abort output a warning:\n   * If error happened with AsyncStorage\n   * @param {String} key - the key of the item\n   * @return {Promise}\n   */\n  removeItem(key) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      logger.debug(`Remove item: key is ${key}`);\n      if (!key || key === currentSizeKey) {\n        logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n        return;\n      }\n      const prefixedKey = `${_this4.config.keyPrefix}${key}`;\n      try {\n        const val = yield _this4.getStorage().getItem(prefixedKey);\n        if (val) {\n          yield _this4.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n        }\n      } catch (e) {\n        logger.warn(`removeItem failed! ${e}`);\n      }\n    })();\n  }\n  /**\n   * Return all the keys owned by this cache.\n   * Will return an empty array if error occurred.\n   *\n   * @return {Promise}\n   */\n  getAllKeys() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this5.getAllCacheKeys();\n      } catch (e) {\n        logger.warn(`getAllkeys failed! ${e}`);\n        return [];\n      }\n    })();\n  }\n  getStorage() {\n    return this.keyValueStorage;\n  }\n  /**\n   * check whether item is expired\n   *\n   * @param key - the key of the item\n   *\n   * @return true if the item is expired.\n   */\n  isExpired(key) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const text = yield _this6.getStorage().getItem(key);\n      assert(text !== null, CacheErrorCode.NoCacheItem, `Key: ${key}`);\n      const item = JSON.parse(text);\n      if (getCurrentTime() >= item.expires) {\n        return true;\n      }\n      return false;\n    })();\n  }\n  /**\n   * delete item from cache\n   *\n   * @param prefixedKey - the key of the item\n   * @param size - optional, the byte size of the item\n   */\n  removeCacheItem(prefixedKey, size) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const item = yield _this7.getStorage().getItem(prefixedKey);\n      assert(item !== null, CacheErrorCode.NoCacheItem, `Key: ${prefixedKey}`);\n      const itemSize = size ?? JSON.parse(item).byteSize;\n      // first try to update the current size of the cache\n      yield _this7.decreaseCurrentSizeInBytes(itemSize);\n      // try to remove the item from cache\n      try {\n        yield _this7.getStorage().removeItem(prefixedKey);\n      } catch (removeItemError) {\n        // if some error happened, we need to rollback the current size\n        yield _this7.increaseCurrentSizeInBytes(itemSize);\n        logger.error(`Failed to remove item: ${removeItemError}`);\n      }\n    })();\n  }\n  /**\n   * produce a JSON object with meta-data and data value\n   * @param value - the value of the item\n   * @param options - optional, the specified meta-data\n   *\n   * @return - the item which has the meta-data and the value\n   */\n  fillCacheItem(key, value, options) {\n    const item = {\n      key,\n      data: value,\n      timestamp: getCurrentTime(),\n      visitedTime: getCurrentTime(),\n      priority: options.priority ?? 0,\n      expires: options.expires ?? 0,\n      type: typeof value,\n      byteSize: 0\n    };\n    // calculate byte size\n    item.byteSize = getByteLength(JSON.stringify(item));\n    // re-calculate using cache item with updated byteSize property\n    item.byteSize = getByteLength(JSON.stringify(item));\n    return item;\n  }\n  sanitizeConfig() {\n    if (this.config.itemMaxSize > this.config.capacityInBytes) {\n      logger.error('Invalid parameter: itemMaxSize. It should be smaller than capacityInBytes. Setting back to default.');\n      this.config.itemMaxSize = defaultConfig.itemMaxSize;\n    }\n    if (this.config.defaultPriority > 5 || this.config.defaultPriority < 1) {\n      logger.error('Invalid parameter: defaultPriority. It should be between 1 and 5. Setting back to default.');\n      this.config.defaultPriority = defaultConfig.defaultPriority;\n    }\n    if (Number(this.config.warningThreshold) > 1 || Number(this.config.warningThreshold) < 0) {\n      logger.error('Invalid parameter: warningThreshold. It should be between 0 and 1. Setting back to default.');\n      this.config.warningThreshold = defaultConfig.warningThreshold;\n    }\n    // Set 5MB limit\n    const cacheLimit = 5 * 1024 * 1024;\n    if (this.config.capacityInBytes > cacheLimit) {\n      logger.error('Cache Capacity should be less than 5MB. Setting back to default. Setting back to default.');\n      this.config.capacityInBytes = defaultConfig.capacityInBytes;\n    }\n  }\n  /**\n   * increase current size of the cache\n   *\n   * @param amount - the amount of the cache szie which need to be increased\n   */\n  increaseCurrentSizeInBytes(amount) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const size = yield _this8.getCurrentCacheSize();\n      yield _this8.getStorage().setItem(getCurrentSizeKey(_this8.config.keyPrefix), (size + amount).toString());\n    })();\n  }\n  /**\n   * decrease current size of the cache\n   *\n   * @param amount - the amount of the cache size which needs to be decreased\n   */\n  decreaseCurrentSizeInBytes(amount) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const size = yield _this9.getCurrentCacheSize();\n      yield _this9.getStorage().setItem(getCurrentSizeKey(_this9.config.keyPrefix), (size - amount).toString());\n    })();\n  }\n  /**\n   * update the visited time if item has been visited\n   *\n   * @param item - the item which need to be updated\n   * @param prefixedKey - the key of the item\n   *\n   * @return the updated item\n   */\n  updateVisitedTime(item, prefixedKey) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      item.visitedTime = getCurrentTime();\n      yield _this10.getStorage().setItem(prefixedKey, JSON.stringify(item));\n      return item;\n    })();\n  }\n  /**\n   * put item into cache\n   *\n   * @param prefixedKey - the key of the item\n   * @param itemData - the value of the item\n   * @param itemSizeInBytes - the byte size of the item\n   */\n  setCacheItem(prefixedKey, item) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      // first try to update the current size of the cache.\n      yield _this11.increaseCurrentSizeInBytes(item.byteSize);\n      // try to add the item into cache\n      try {\n        yield _this11.getStorage().setItem(prefixedKey, JSON.stringify(item));\n      } catch (setItemErr) {\n        // if some error happened, we need to rollback the current size\n        yield _this11.decreaseCurrentSizeInBytes(item.byteSize);\n        logger.error(`Failed to set item ${setItemErr}`);\n      }\n    })();\n  }\n  /**\n   * total space needed when poping out items\n   *\n   * @param itemSize\n   *\n   * @return total space needed\n   */\n  sizeToPop(itemSize) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const cur = yield _this12.getCurrentCacheSize();\n      const spaceItemNeed = cur + itemSize - _this12.config.capacityInBytes;\n      const cacheThresholdSpace = (1 - _this12.config.warningThreshold) * _this12.config.capacityInBytes;\n      return spaceItemNeed > cacheThresholdSpace ? spaceItemNeed : cacheThresholdSpace;\n    })();\n  }\n  /**\n   * see whether cache is full\n   *\n   * @param itemSize\n   *\n   * @return true if cache is full\n   */\n  isCacheFull(itemSize) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const cur = yield _this13.getCurrentCacheSize();\n      return itemSize + cur > _this13.config.capacityInBytes;\n    })();\n  }\n  /**\n   * get all the items we have, sort them by their priority,\n   * if priority is same, sort them by their last visited time\n   * pop out items from the low priority (5 is the lowest)\n   * @private\n   * @param keys - all the keys in this cache\n   * @param sizeToPop - the total size of the items which needed to be poped out\n   */\n  popOutItems(keys, sizeToPop) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const items = [];\n      let remainedSize = sizeToPop;\n      for (const key of keys) {\n        const val = yield _this14.getStorage().getItem(key);\n        if (val != null) {\n          const item = JSON.parse(val);\n          items.push(item);\n        }\n      }\n      // first compare priority\n      // then compare visited time\n      items.sort((a, b) => {\n        if (a.priority > b.priority) {\n          return -1;\n        } else if (a.priority < b.priority) {\n          return 1;\n        } else {\n          if (a.visitedTime < b.visitedTime) {\n            return -1;\n          } else return 1;\n        }\n      });\n      for (const item of items) {\n        // pop out items until we have enough room for new item\n        yield _this14.removeCacheItem(item.key, item.byteSize);\n        remainedSize -= item.byteSize;\n        if (remainedSize <= 0) {\n          return;\n        }\n      }\n    })();\n  }\n  /**\n   * Scan the storage and combine the following operations for efficiency\n   *   1. Clear out all expired keys owned by this cache, not including the size key.\n   *   2. Return the remaining keys.\n   *\n   * @return The remaining valid keys\n   */\n  clearInvalidAndGetRemainingKeys() {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const remainingKeys = [];\n      const keys = yield _this15.getAllCacheKeys({\n        omitSizeKey: true\n      });\n      for (const key of keys) {\n        if (yield _this15.isExpired(key)) {\n          yield _this15.removeCacheItem(key);\n        } else {\n          remainingKeys.push(key);\n        }\n      }\n      return remainingKeys;\n    })();\n  }\n  /**\n   * clear the entire cache\n   * The cache will abort and output a warning if error occurs\n   * @return {Promise}\n   */\n  clear() {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      logger.debug(`Clear Cache`);\n      try {\n        const keys = yield _this16.getAllKeys();\n        for (const key of keys) {\n          yield _this16.getStorage().removeItem(key);\n        }\n      } catch (e) {\n        logger.warn(`clear failed! ${e}`);\n      }\n    })();\n  }\n}\nexport { StorageCacheCommon };\n//# sourceMappingURL=StorageCacheCommon.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}