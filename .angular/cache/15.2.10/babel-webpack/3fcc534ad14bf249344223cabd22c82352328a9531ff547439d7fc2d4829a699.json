{"ast":null,"code":"import { getActorContext, getActorState } from './actor.mjs';\nimport { NAVIGABLE_ROUTE_EVENT } from './constants.mjs';\nimport { getRoute } from './getRoute.mjs';\n\n/**\n * This file contains helpers that translates xstate internals to more\n * understandable authenticator contexts. We provide these contexts with\n * `useAuthenticator` hook/composable/service.\n */\n/**\n * Creates public facing auth helpers that abstracts out xstate implementation\n * detail. Each framework implementation can export these helpers so that\n * developers can send events without having to learn internals.\n *\n * ```\n * const [state, send] = useActor(...);\n * const { submit } = getSendEventAliases(send);\n * submit({ username, password})\n * ```\n */\nconst getSendEventAliases = send => {\n  const sendToMachine = type => {\n    // TODO If these were created during the creation of the machine & provider,\n    // then invalid transitions could be caught via https://xstate.js.org/docs/guides/states.html#state-can-event\n    return data => send({\n      type,\n      data\n    });\n  };\n  return {\n    initializeMachine: sendToMachine('INIT'),\n    resendCode: sendToMachine('RESEND'),\n    signOut: sendToMachine('SIGN_OUT'),\n    submitForm: sendToMachine('SUBMIT'),\n    updateForm: sendToMachine('CHANGE'),\n    updateBlur: sendToMachine('BLUR'),\n    // Actions that don't immediately invoke a service but instead transition to a screen\n    // are prefixed with `to*`\n    toFederatedSignIn: sendToMachine('FEDERATED_SIGN_IN'),\n    toForgotPassword: sendToMachine('FORGOT_PASSWORD'),\n    toSignIn: sendToMachine('SIGN_IN'),\n    toSignUp: sendToMachine('SIGN_UP'),\n    skipVerification: sendToMachine('SKIP')\n  };\n};\nconst getNextSendEventAliases = send => {\n  const {\n    toFederatedSignIn,\n    submitForm,\n    resendCode,\n    skipVerification\n  } = getSendEventAliases(send);\n  return {\n    handleSubmit: submitForm,\n    resendConfirmationCode: resendCode,\n    // manual \"route\" navigation\n    setRoute: route => send({\n      type: NAVIGABLE_ROUTE_EVENT[route]\n    }),\n    skipAttributeVerification: skipVerification,\n    toFederatedSignIn\n  };\n};\nconst getServiceContextFacade = state => {\n  const actorContext = getActorContext(state) ?? {};\n  const {\n    challengeName,\n    codeDeliveryDetails,\n    remoteError: error,\n    validationError: validationErrors,\n    totpSecretCode = null,\n    unverifiedUserAttributes,\n    username\n  } = actorContext;\n  const {\n    socialProviders = []\n  } = state.context?.config ?? {};\n  // check for user in actorContext prior to state context. actorContext is more \"up to date\",\n  // but is not available on all states\n  const user = actorContext?.user ?? state.context?.user;\n  const hasValidationErrors = !!(validationErrors && Object.keys(validationErrors).length > 0);\n  const actorState = getActorState(state);\n  const isPending = state.hasTag('pending') || actorState?.hasTag('pending');\n  const route = getRoute(state, actorState);\n  // Auth status represents the current state of the auth flow\n  // The `configuring` state is used to indicate when the xState machine is loading\n  const authStatus = (route => {\n    switch (route) {\n      case 'idle':\n      case 'setup':\n        return 'configuring';\n      case 'authenticated':\n        return 'authenticated';\n      default:\n        return 'unauthenticated';\n    }\n  })(route);\n  const facade = {\n    authStatus,\n    challengeName,\n    codeDeliveryDetails,\n    error,\n    hasValidationErrors,\n    isPending,\n    route,\n    socialProviders,\n    totpSecretCode,\n    unverifiedUserAttributes,\n    user,\n    username,\n    validationErrors\n    // @v6-migration-note\n    // While most of the properties\n    // on `AuthenticatorServiceContextFacade` can resolve to `undefined`, updating\n    // the interface requires material changes in consumers (namely `useAutenticator`)\n    // which will have implications on the UI layer as typeguards and non-null checks\n    // are required to pass type checking. As the `Authenticator` is behaving as expected\n    // with the `AuthenticatorServiceContextFacade` interface, prefer to cast\n  };\n\n  return facade;\n};\nconst getNextServiceContextFacade = state => {\n  const actorContext = getActorContext(state) ?? {};\n  const {\n    challengeName,\n    codeDeliveryDetails,\n    remoteError: errorMessage,\n    totpSecretCode,\n    unverifiedUserAttributes,\n    username\n  } = actorContext;\n  const {\n    socialProviders: federatedProviders,\n    loginMechanisms\n  } = state.context?.config ?? {};\n  const loginMechanism = loginMechanisms?.[0];\n  const actorState = getActorState(state);\n  const isPending = state.hasTag('pending') || actorState?.hasTag('pending');\n  // @todo-migration remove this cast for Authenticator.Next\n  const route = getRoute(state, actorState);\n  return {\n    challengeName,\n    codeDeliveryDetails,\n    errorMessage,\n    federatedProviders,\n    isPending,\n    loginMechanism,\n    route,\n    totpSecretCode,\n    unverifiedUserAttributes,\n    username\n  };\n};\nconst getServiceFacade = ({\n  send,\n  state\n}) => {\n  const sendEventAliases = getSendEventAliases(send);\n  const serviceContext = getServiceContextFacade(state);\n  return {\n    ...sendEventAliases,\n    ...serviceContext\n  };\n};\nconst getNextServiceFacade = ({\n  send,\n  state\n}) => ({\n  ...getNextSendEventAliases(send),\n  ...getNextServiceContextFacade(state)\n});\nexport { getNextServiceContextFacade, getNextServiceFacade, getSendEventAliases, getServiceContextFacade, getServiceFacade };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}