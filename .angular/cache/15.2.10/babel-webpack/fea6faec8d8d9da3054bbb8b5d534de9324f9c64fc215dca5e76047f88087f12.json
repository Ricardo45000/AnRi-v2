{"ast":null,"code":"import _asyncToGenerator from \"/Users/ricardoda-silva/Desktop/Project/RiAn/AnRi v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { AuthError } from '../../../../../errors/AuthError.mjs';\nimport { textEncoder } from '../../textEncoder/index.mjs';\nimport BigInteger from '../BigInteger/BigInteger.mjs';\nimport { calculateS } from '../calculate/calculateS.mjs';\nimport { calculateU } from '../calculate/calculateU.mjs';\nimport { getBytesFromHex } from '../getBytesFromHex.mjs';\nimport { getHashFromData } from '../getHashFromData.mjs';\nimport { getHashFromHex } from '../getHashFromHex.mjs';\nimport { getHexFromBytes } from '../getHexFromBytes.mjs';\nimport { getHkdfKey } from '../getHkdfKey.mjs';\nimport { getPaddedHex } from '../getPaddedHex.mjs';\nimport { getRandomBytes } from '../getRandomBytes.mjs';\nimport { getRandomString } from '../getRandomString.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/** @class */\nclass AuthenticationHelper {\n  constructor({\n    userPoolName,\n    a,\n    g,\n    A,\n    N\n  }) {\n    this.encoder = textEncoder;\n    this.userPoolName = userPoolName;\n    this.a = a;\n    this.g = g;\n    this.A = A;\n    this.N = N;\n    this.k = new BigInteger(getHashFromHex(`${getPaddedHex(N)}${getPaddedHex(g)}`), 16);\n  }\n  /**\n   * @returns {string} Generated random value included in password hash.\n   */\n  getRandomPassword() {\n    if (!this.randomPassword) {\n      throw new AuthError({\n        name: 'EmptyBigIntegerRandomPassword',\n        message: 'random password is empty'\n      });\n    }\n    return this.randomPassword;\n  }\n  /**\n   * @returns {string} Generated random value included in devices hash.\n   */\n  getSaltToHashDevices() {\n    if (!this.saltToHashDevices) {\n      throw new AuthError({\n        name: 'EmptyBigIntegersaltToHashDevices',\n        message: 'saltToHashDevices is empty'\n      });\n    }\n    return this.saltToHashDevices;\n  }\n  /**\n   * @returns {string} Value used to verify devices.\n   */\n  getVerifierDevices() {\n    if (!this.verifierDevices) {\n      throw new AuthError({\n        name: 'EmptyBigIntegerVerifierDevices',\n        message: 'verifyDevices is empty'\n      });\n    }\n    return this.verifierDevices;\n  }\n  /**\n   * Generate salts and compute verifier.\n   *\n   * @param {string} deviceGroupKey Devices to generate verifier for.\n   * @param {string} username User to generate verifier for.\n   *\n   * @returns {Promise<void>}\n   */\n  generateHashDevice(deviceGroupKey, username) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.randomPassword = getRandomString();\n      const combinedString = `${deviceGroupKey}${username}:${_this.randomPassword}`;\n      const hashedString = getHashFromData(combinedString);\n      const hexRandom = getHexFromBytes(getRandomBytes(16));\n      // The random hex will be unambiguously represented as a postive integer\n      _this.saltToHashDevices = getPaddedHex(new BigInteger(hexRandom, 16));\n      return new Promise((resolve, reject) => {\n        _this.g.modPow(new BigInteger(getHashFromHex(_this.saltToHashDevices + hashedString), 16), _this.N, (err, result) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          _this.verifierDevices = getPaddedHex(result);\n          resolve();\n        });\n      });\n    })();\n  }\n  /**\n   * Calculates the final HKDF key based on computed S value, computed U value and the key\n   *\n   * @param {String} username Username.\n   * @param {String} password Password.\n   * @param {AuthBigInteger} B Server B value.\n   * @param {AuthBigInteger} salt Generated salt.\n   */\n  getPasswordAuthenticationKey({\n    username,\n    password,\n    serverBValue,\n    salt\n  }) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (serverBValue.mod(_this2.N).equals(BigInteger.ZERO)) {\n        throw new Error('B cannot be zero.');\n      }\n      const U = calculateU({\n        A: _this2.A,\n        B: serverBValue\n      });\n      const usernamePassword = `${_this2.userPoolName}${username}:${password}`;\n      const usernamePasswordHash = getHashFromData(usernamePassword);\n      const x = new BigInteger(getHashFromHex(getPaddedHex(salt) + usernamePasswordHash), 16);\n      const S = yield calculateS({\n        a: _this2.a,\n        g: _this2.g,\n        k: _this2.k,\n        x,\n        B: serverBValue,\n        N: _this2.N,\n        U\n      });\n      const context = _this2.encoder.convert('Caldera Derived Key');\n      const spacer = _this2.encoder.convert(String.fromCharCode(1));\n      const info = new Uint8Array(context.byteLength + spacer.byteLength);\n      info.set(context, 0);\n      info.set(spacer, context.byteLength);\n      const hkdfKey = getHkdfKey(getBytesFromHex(getPaddedHex(S)), getBytesFromHex(getPaddedHex(U)), info);\n      return hkdfKey;\n    })();\n  }\n}\nexport { AuthenticationHelper as default };\n//# sourceMappingURL=AuthenticationHelper.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}