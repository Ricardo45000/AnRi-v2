{"ast":null,"code":"import { ConsoleLogger } from '../Logger/ConsoleLogger.mjs';\nimport { NO_HUBCALLBACK_PROVIDED_EXCEPTION } from '../constants.mjs';\nimport { AmplifyError } from '../errors/AmplifyError.mjs';\nimport '../types/errors.mjs';\nimport '../errors/errorHelpers.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst AMPLIFY_SYMBOL = typeof Symbol !== 'undefined' ? Symbol('amplify_default') : '@@amplify_default';\nconst logger = new ConsoleLogger('Hub');\nclass HubClass {\n  constructor(name) {\n    this.listeners = new Map();\n    this.protectedChannels = ['core', 'auth', 'api', 'analytics', 'interactions', 'pubsub', 'storage', 'ui', 'xr'];\n    this.name = name;\n  }\n  /**\n   * Used internally to remove a Hub listener.\n   *\n   * @remarks\n   * This private method is for internal use only. Instead of calling Hub.remove, call the result of Hub.listen.\n   */\n  _remove(channel, listener) {\n    const holder = this.listeners.get(channel);\n    if (!holder) {\n      logger.warn(`No listeners for ${channel}`);\n      return;\n    }\n    this.listeners.set(channel, [...holder.filter(({\n      callback\n    }) => callback !== listener)]);\n  }\n  dispatch(channel, payload, source, ampSymbol) {\n    if (typeof channel === 'string' && this.protectedChannels.indexOf(channel) > -1) {\n      const hasAccess = ampSymbol === AMPLIFY_SYMBOL;\n      if (!hasAccess) {\n        logger.warn(`WARNING: ${channel} is protected and dispatching on it can have unintended consequences`);\n      }\n    }\n    const capsule = {\n      channel,\n      payload: {\n        ...payload\n      },\n      source,\n      patternInfo: []\n    };\n    try {\n      this._toListeners(capsule);\n    } catch (e) {\n      logger.error(e);\n    }\n  }\n  listen(channel, callback, listenerName = 'noname') {\n    let cb;\n    if (typeof callback !== 'function') {\n      throw new AmplifyError({\n        name: NO_HUBCALLBACK_PROVIDED_EXCEPTION,\n        message: 'No callback supplied to Hub'\n      });\n    } else {\n      // Needs to be casted as a more generic type\n      cb = callback;\n    }\n    let holder = this.listeners.get(channel);\n    if (!holder) {\n      holder = [];\n      this.listeners.set(channel, holder);\n    }\n    holder.push({\n      name: listenerName,\n      callback: cb\n    });\n    return () => {\n      this._remove(channel, cb);\n    };\n  }\n  _toListeners(capsule) {\n    const {\n      channel,\n      payload\n    } = capsule;\n    const holder = this.listeners.get(channel);\n    if (holder) {\n      holder.forEach(listener => {\n        logger.debug(`Dispatching to ${channel} with `, payload);\n        try {\n          listener.callback(capsule);\n        } catch (e) {\n          logger.error(e);\n        }\n      });\n    }\n  }\n}\n/* We export a __default__ instance of HubClass to use it as a\npseudo Singleton for the main messaging bus, however you can still create\nyour own instance of HubClass() for a separate \"private bus\" of events. */\nconst Hub = new HubClass('__default__');\n/**\n * @internal\n *\n * Internal hub used for core Amplify functionality. Not intended for use outside of Amplify.\n *\n */\nconst HubInternal = new HubClass('internal-hub');\nexport { AMPLIFY_SYMBOL, Hub, HubClass, HubInternal };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}