{"ast":null,"code":"import _asyncToGenerator from \"/Users/ricardoda-silva/Desktop/Project/RiAn/AnRi v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ConsoleLogger, getCredentialsForIdentity } from '@aws-amplify/core';\nimport { assertIdentityPoolIdConfig } from '@aws-amplify/core/internals/utils';\nimport { AuthError } from '../../../errors/AuthError.mjs';\nimport { getRegionFromIdentityPoolId } from '../utils/clients/CognitoIdentityProvider/utils.mjs';\nimport { assertIdTokenInAuthTokens } from '../utils/types.mjs';\nimport { cognitoIdentityIdProvider } from './IdentityIdProvider.mjs';\nimport { formLoginsMap } from './utils.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('CognitoCredentialsProvider');\nconst CREDENTIALS_TTL = 50 * 60 * 1000; // 50 min, can be modified on config if required in the future\nclass CognitoAWSCredentialsAndIdentityIdProvider {\n  constructor(identityIdStore) {\n    this._nextCredentialsRefresh = 0;\n    this._identityIdStore = identityIdStore;\n  }\n  clearCredentialsAndIdentityId() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      logger.debug('Clearing out credentials and identityId');\n      _this._credentialsAndIdentityId = undefined;\n      yield _this._identityIdStore.clearIdentityId();\n    })();\n  }\n  clearCredentials() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      logger.debug('Clearing out in-memory credentials');\n      _this2._credentialsAndIdentityId = undefined;\n    })();\n  }\n  getCredentialsAndIdentityId(getCredentialsOptions) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const isAuthenticated = getCredentialsOptions.authenticated;\n      const {\n        tokens\n      } = getCredentialsOptions;\n      const {\n        authConfig\n      } = getCredentialsOptions;\n      try {\n        assertIdentityPoolIdConfig(authConfig?.Cognito);\n      } catch {\n        // No identity pool configured, skipping\n        return;\n      }\n      if (!isAuthenticated && !authConfig.Cognito.allowGuestAccess) {\n        // TODO(V6): return partial result like Native platforms\n        return;\n      }\n      const {\n        forceRefresh\n      } = getCredentialsOptions;\n      const tokenHasChanged = _this3.hasTokenChanged(tokens);\n      const identityId = yield cognitoIdentityIdProvider({\n        tokens,\n        authConfig: authConfig.Cognito,\n        identityIdStore: _this3._identityIdStore\n      });\n      // Clear cached credentials when forceRefresh is true OR the cache token has changed\n      if (forceRefresh || tokenHasChanged) {\n        _this3.clearCredentials();\n      }\n      if (!isAuthenticated) {\n        return _this3.getGuestCredentials(identityId, authConfig.Cognito);\n      } else {\n        assertIdTokenInAuthTokens(tokens);\n        return _this3.credsForOIDCTokens(authConfig.Cognito, tokens, identityId);\n      }\n    })();\n  }\n  getGuestCredentials(identityId, authConfig) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // Return existing in-memory cached credentials only if it exists, is not past it's lifetime and is unauthenticated credentials\n      if (_this4._credentialsAndIdentityId && !_this4.isPastTTL() && _this4._credentialsAndIdentityId.isAuthenticatedCreds === false) {\n        logger.info('returning stored credentials as they neither past TTL nor expired.');\n        return _this4._credentialsAndIdentityId;\n      }\n      // Clear to discard if any authenticated credentials are set and start with a clean slate\n      _this4.clearCredentials();\n      const region = getRegionFromIdentityPoolId(authConfig.identityPoolId);\n      // use identityId to obtain guest credentials\n      // save credentials in-memory\n      // No logins params should be passed for guest creds:\n      // https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html\n      const clientResult = yield getCredentialsForIdentity({\n        region\n      }, {\n        IdentityId: identityId\n      });\n      if (clientResult.Credentials && clientResult.Credentials.AccessKeyId && clientResult.Credentials.SecretKey) {\n        _this4._nextCredentialsRefresh = new Date().getTime() + CREDENTIALS_TTL;\n        const res = {\n          credentials: {\n            accessKeyId: clientResult.Credentials.AccessKeyId,\n            secretAccessKey: clientResult.Credentials.SecretKey,\n            sessionToken: clientResult.Credentials.SessionToken,\n            expiration: clientResult.Credentials.Expiration\n          },\n          identityId\n        };\n        const identityIdRes = clientResult.IdentityId;\n        if (identityIdRes) {\n          res.identityId = identityIdRes;\n          _this4._identityIdStore.storeIdentityId({\n            id: identityIdRes,\n            type: 'guest'\n          });\n        }\n        _this4._credentialsAndIdentityId = {\n          ...res,\n          isAuthenticatedCreds: false\n        };\n        return res;\n      } else {\n        throw new AuthError({\n          name: 'CredentialsNotFoundException',\n          message: `Cognito did not respond with either Credentials, AccessKeyId or SecretKey.`\n        });\n      }\n    })();\n  }\n  credsForOIDCTokens(authConfig, authTokens, identityId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (_this5._credentialsAndIdentityId && !_this5.isPastTTL() && _this5._credentialsAndIdentityId.isAuthenticatedCreds === true) {\n        logger.debug('returning stored credentials as they neither past TTL nor expired.');\n        return _this5._credentialsAndIdentityId;\n      }\n      // Clear to discard if any unauthenticated credentials are set and start with a clean slate\n      _this5.clearCredentials();\n      const logins = authTokens.idToken ? formLoginsMap(authTokens.idToken.toString()) : {};\n      const region = getRegionFromIdentityPoolId(authConfig.identityPoolId);\n      const clientResult = yield getCredentialsForIdentity({\n        region\n      }, {\n        IdentityId: identityId,\n        Logins: logins\n      });\n      if (clientResult.Credentials && clientResult.Credentials.AccessKeyId && clientResult.Credentials.SecretKey) {\n        const res = {\n          credentials: {\n            accessKeyId: clientResult.Credentials.AccessKeyId,\n            secretAccessKey: clientResult.Credentials.SecretKey,\n            sessionToken: clientResult.Credentials.SessionToken,\n            expiration: clientResult.Credentials.Expiration\n          },\n          identityId\n        };\n        // Store the credentials in-memory along with the expiration\n        _this5._credentialsAndIdentityId = {\n          ...res,\n          isAuthenticatedCreds: true,\n          associatedIdToken: authTokens.idToken?.toString()\n        };\n        _this5._nextCredentialsRefresh = new Date().getTime() + CREDENTIALS_TTL;\n        const identityIdRes = clientResult.IdentityId;\n        if (identityIdRes) {\n          res.identityId = identityIdRes;\n          _this5._identityIdStore.storeIdentityId({\n            id: identityIdRes,\n            type: 'primary'\n          });\n        }\n        return res;\n      } else {\n        throw new AuthError({\n          name: 'CredentialsException',\n          message: `Cognito did not respond with either Credentials, AccessKeyId or SecretKey.`\n        });\n      }\n    })();\n  }\n  isPastTTL() {\n    return this._nextCredentialsRefresh === undefined ? true : this._nextCredentialsRefresh <= Date.now();\n  }\n  hasTokenChanged(tokens) {\n    return !!tokens && !!this._credentialsAndIdentityId?.associatedIdToken && tokens.idToken?.toString() !== this._credentialsAndIdentityId.associatedIdToken;\n  }\n}\nexport { CognitoAWSCredentialsAndIdentityIdProvider };\n//# sourceMappingURL=credentialsProvider.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}