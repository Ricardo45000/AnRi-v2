{"ast":null,"code":"import _asyncToGenerator from \"/Users/ricardoda-silva/Desktop/Project/RiAn/AnRi v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { AmplifyUrl, USER_AGENT_HEADER, urlSafeDecode, AMPLIFY_SYMBOL } from '@aws-amplify/core/internals/utils';\nimport { decodeJWT, Hub } from '@aws-amplify/core';\nimport { cacheCognitoTokens } from '../../tokenProvider/cacheTokens.mjs';\nimport '../refreshAuthTokens.mjs';\nimport '../../tokenProvider/errorHelpers.mjs';\nimport { cognitoUserPoolsTokenProvider } from '../../tokenProvider/tokenProvider.mjs';\nimport { dispatchSignedInHubEvent } from '../dispatchSignedInHubEvent.mjs';\nimport { createOAuthError } from './createOAuthError.mjs';\nimport { resolveAndClearInflightPromises } from './inflightPromise.mjs';\nimport { validateState } from './validateState.mjs';\nimport { oAuthStore } from './oAuthStore.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst completeOAuthFlow = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* ({\n    currentUrl,\n    userAgentValue,\n    clientId,\n    redirectUri,\n    responseType,\n    domain,\n    preferPrivateSession\n  }) {\n    const urlParams = new AmplifyUrl(currentUrl);\n    const error = urlParams.searchParams.get('error');\n    const errorMessage = urlParams.searchParams.get('error_description');\n    if (error) {\n      throw createOAuthError(errorMessage ?? error);\n    }\n    if (responseType === 'code') {\n      return handleCodeFlow({\n        currentUrl,\n        userAgentValue,\n        clientId,\n        redirectUri,\n        domain,\n        preferPrivateSession\n      });\n    }\n    return handleImplicitFlow({\n      currentUrl,\n      redirectUri,\n      preferPrivateSession\n    });\n  });\n  return function completeOAuthFlow(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst handleCodeFlow = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* ({\n    currentUrl,\n    userAgentValue,\n    clientId,\n    redirectUri,\n    domain,\n    preferPrivateSession\n  }) {\n    /* Convert URL into an object with parameters as keys\n    { redirect_uri: 'http://localhost:3000/', response_type: 'code', ...} */\n    const url = new AmplifyUrl(currentUrl);\n    const code = url.searchParams.get('code');\n    const state = url.searchParams.get('state');\n    // if `code` or `state` is not presented in the redirect url, most likely\n    // that the end user cancelled the inflight oauth flow by:\n    // 1. clicking the back button of browser\n    // 2. closing the provider hosted UI page and coming back to the app\n    if (!code || !state) {\n      throw createOAuthError('User cancelled OAuth flow.');\n    }\n    // may throw error is being caught in attemptCompleteOAuthFlow.ts\n    const validatedState = yield validateState(state);\n    const oAuthTokenEndpoint = 'https://' + domain + '/oauth2/token';\n    // TODO(v6): check hub events\n    // dispatchAuthEvent(\n    // \t'codeFlow',\n    // \t{},\n    // \t`Retrieving tokens from ${oAuthTokenEndpoint}`\n    // );\n    const codeVerifier = yield oAuthStore.loadPKCE();\n    const oAuthTokenBody = {\n      grant_type: 'authorization_code',\n      code,\n      client_id: clientId,\n      redirect_uri: redirectUri,\n      ...(codeVerifier ? {\n        code_verifier: codeVerifier\n      } : {})\n    };\n    const body = Object.entries(oAuthTokenBody).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n    const {\n      access_token,\n      refresh_token: refreshToken,\n      id_token,\n      error,\n      error_message: errorMessage,\n      token_type,\n      expires_in\n    } = yield (yield fetch(oAuthTokenEndpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        [USER_AGENT_HEADER]: userAgentValue\n      },\n      body\n    })).json();\n    if (error) {\n      // error is being caught in attemptCompleteOAuthFlow.ts\n      throw createOAuthError(errorMessage ?? error);\n    }\n    const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n    yield cacheCognitoTokens({\n      username,\n      AccessToken: access_token,\n      IdToken: id_token,\n      RefreshToken: refreshToken,\n      TokenType: token_type,\n      ExpiresIn: expires_in\n    });\n    return completeFlow({\n      redirectUri,\n      state: validatedState,\n      preferPrivateSession\n    });\n  });\n  return function handleCodeFlow(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nconst handleImplicitFlow = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* ({\n    currentUrl,\n    redirectUri,\n    preferPrivateSession\n  }) {\n    // hash is `null` if `#` doesn't exist on URL\n    const url = new AmplifyUrl(currentUrl);\n    const {\n      id_token,\n      access_token,\n      state,\n      token_type,\n      expires_in,\n      error_description,\n      error\n    } = (url.hash ?? '#').substring(1) // Remove # from returned code\n    .split('&').map(pairings => pairings.split('=')).reduce((accum, [k, v]) => ({\n      ...accum,\n      [k]: v\n    }), {\n      id_token: undefined,\n      access_token: undefined,\n      state: undefined,\n      token_type: undefined,\n      expires_in: undefined,\n      error_description: undefined,\n      error: undefined\n    });\n    if (error) {\n      throw createOAuthError(error_description ?? error);\n    }\n    if (!access_token) {\n      // error is being caught in attemptCompleteOAuthFlow.ts\n      throw createOAuthError('No access token returned from OAuth flow.');\n    }\n    const validatedState = yield validateState(state);\n    const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n    yield cacheCognitoTokens({\n      username,\n      AccessToken: access_token,\n      IdToken: id_token,\n      TokenType: token_type,\n      ExpiresIn: expires_in\n    });\n    return completeFlow({\n      redirectUri,\n      state: validatedState,\n      preferPrivateSession\n    });\n  });\n  return function handleImplicitFlow(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nconst completeFlow = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* ({\n    redirectUri,\n    state,\n    preferPrivateSession\n  }) {\n    yield oAuthStore.clearOAuthData();\n    yield oAuthStore.storeOAuthSignIn(true, preferPrivateSession);\n    // this should be called before any call that involves `fetchAuthSession`\n    // e.g. `getCurrentUser()` below, so it allows every inflight async calls to\n    //  `fetchAuthSession` can be resolved\n    resolveAndClearInflightPromises();\n    // when the oauth flow is completed, there should be nothing to block the async calls\n    // that involves fetchAuthSession in the `TokenOrchestrator`\n    cognitoUserPoolsTokenProvider.setWaitForInflightOAuth( /*#__PURE__*/_asyncToGenerator(function* () {\n      // no-op\n    }));\n    if (isCustomState(state)) {\n      Hub.dispatch('auth', {\n        event: 'customOAuthState',\n        data: urlSafeDecode(getCustomState(state))\n      }, 'Auth', AMPLIFY_SYMBOL);\n    }\n    Hub.dispatch('auth', {\n      event: 'signInWithRedirect'\n    }, 'Auth', AMPLIFY_SYMBOL);\n    yield dispatchSignedInHubEvent();\n    clearHistory(redirectUri);\n  });\n  return function completeFlow(_x4) {\n    return _ref4.apply(this, arguments);\n  };\n}();\nconst isCustomState = state => {\n  return /-/.test(state);\n};\nconst getCustomState = state => {\n  return state.split('-').splice(1).join('-');\n};\nconst clearHistory = redirectUri => {\n  if (typeof window !== 'undefined' && typeof window.history !== 'undefined') {\n    window.history.replaceState(window.history.state, '', redirectUri);\n  }\n};\nexport { completeOAuthFlow };\n//# sourceMappingURL=completeOAuthFlow.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}