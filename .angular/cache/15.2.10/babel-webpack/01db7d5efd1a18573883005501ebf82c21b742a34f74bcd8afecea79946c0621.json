{"ast":null,"code":"import _asyncToGenerator from \"/Users/ricardoda-silva/Desktop/Project/RiAn/AnRi v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Amplify } from '@aws-amplify/core';\nimport { AuthAction, assertTokenProviderConfig, AmplifyUrl, base64Encoder } from '@aws-amplify/core/internals/utils';\nimport { AuthError } from '../../../errors/AuthError.mjs';\nimport { InitiateAuthException } from '../types/errors.mjs';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings.mjs';\nimport { AuthValidationErrorCode } from '../../../errors/types/validation.mjs';\nimport { assertValidationError } from '../../../errors/utils/assertValidationError.mjs';\nimport { USER_ALREADY_AUTHENTICATED_EXCEPTION } from '../../../errors/constants.mjs';\nimport { getCurrentUser } from '../apis/getCurrentUser.mjs';\nimport { getAuthUserAgentValue } from '../../../utils/getAuthUserAgentValue.mjs';\nimport { signInStore } from './signInStore.mjs';\nimport { respondToAuthChallenge, verifySoftwareToken, initiateAuth, associateSoftwareToken, confirmDevice } from './clients/CognitoIdentityProvider/index.mjs';\nimport { getRegion } from './clients/CognitoIdentityProvider/utils.mjs';\nimport { assertDeviceMetadata } from './types.mjs';\nimport { getAuthenticationHelper } from './srp/getAuthenticationHelper.mjs';\nimport { getBytesFromHex } from './srp/getBytesFromHex.mjs';\nimport { getNowString } from './srp/getNowString.mjs';\nimport { getSignatureString } from './srp/getSignatureString.mjs';\nimport BigInteger from './srp/BigInteger/BigInteger.mjs';\nimport { getUserContextData } from './userContextData.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst USER_ATTRIBUTES = 'userAttributes.';\nfunction handleCustomChallenge(_x) {\n  return _handleCustomChallenge.apply(this, arguments);\n}\nfunction _handleCustomChallenge() {\n  _handleCustomChallenge = _asyncToGenerator(function* ({\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    config,\n    tokenOrchestrator\n  }) {\n    const {\n      userPoolId,\n      userPoolClientId\n    } = config;\n    const challengeResponses = {\n      USERNAME: username,\n      ANSWER: challengeResponse\n    };\n    const deviceMetadata = yield tokenOrchestrator?.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n      challengeResponses.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReq = {\n      ChallengeName: 'CUSTOM_CHALLENGE',\n      ChallengeResponses: challengeResponses,\n      Session: session,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId,\n      UserContextData\n    };\n    const response = yield respondToAuthChallenge({\n      region: getRegion(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n    }, jsonReq);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH') {\n      return handleDeviceSRPAuth({\n        username,\n        config,\n        clientMetadata,\n        session: response.Session,\n        tokenOrchestrator\n      });\n    }\n    return response;\n  });\n  return _handleCustomChallenge.apply(this, arguments);\n}\nfunction handleMFASetupChallenge(_x2) {\n  return _handleMFASetupChallenge.apply(this, arguments);\n}\nfunction _handleMFASetupChallenge() {\n  _handleMFASetupChallenge = _asyncToGenerator(function* ({\n    challengeResponse,\n    username,\n    clientMetadata,\n    session,\n    deviceName,\n    config\n  }) {\n    const {\n      userPoolId,\n      userPoolClientId\n    } = config;\n    const challengeResponses = {\n      USERNAME: username\n    };\n    const {\n      Session\n    } = yield verifySoftwareToken({\n      region: getRegion(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n    }, {\n      UserCode: challengeResponse,\n      Session: session,\n      FriendlyDeviceName: deviceName\n    });\n    signInStore.dispatch({\n      type: 'SET_SIGN_IN_SESSION',\n      value: Session\n    });\n    const jsonReq = {\n      ChallengeName: 'MFA_SETUP',\n      ChallengeResponses: challengeResponses,\n      Session,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId\n    };\n    return respondToAuthChallenge({\n      region: getRegion(userPoolId)\n    }, jsonReq);\n  });\n  return _handleMFASetupChallenge.apply(this, arguments);\n}\nfunction handleSelectMFATypeChallenge(_x3) {\n  return _handleSelectMFATypeChallenge.apply(this, arguments);\n}\nfunction _handleSelectMFATypeChallenge() {\n  _handleSelectMFATypeChallenge = _asyncToGenerator(function* ({\n    challengeResponse,\n    username,\n    clientMetadata,\n    session,\n    config\n  }) {\n    const {\n      userPoolId,\n      userPoolClientId\n    } = config;\n    assertValidationError(challengeResponse === 'TOTP' || challengeResponse === 'SMS', AuthValidationErrorCode.IncorrectMFAMethod);\n    const challengeResponses = {\n      USERNAME: username,\n      ANSWER: mapMfaType(challengeResponse)\n    };\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReq = {\n      ChallengeName: 'SELECT_MFA_TYPE',\n      ChallengeResponses: challengeResponses,\n      Session: session,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId,\n      UserContextData\n    };\n    return respondToAuthChallenge({\n      region: getRegion(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n    }, jsonReq);\n  });\n  return _handleSelectMFATypeChallenge.apply(this, arguments);\n}\nfunction handleSMSMFAChallenge(_x4) {\n  return _handleSMSMFAChallenge.apply(this, arguments);\n}\nfunction _handleSMSMFAChallenge() {\n  _handleSMSMFAChallenge = _asyncToGenerator(function* ({\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    config\n  }) {\n    const {\n      userPoolId,\n      userPoolClientId\n    } = config;\n    const challengeResponses = {\n      USERNAME: username,\n      SMS_MFA_CODE: challengeResponse\n    };\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReq = {\n      ChallengeName: 'SMS_MFA',\n      ChallengeResponses: challengeResponses,\n      Session: session,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId,\n      UserContextData\n    };\n    return respondToAuthChallenge({\n      region: getRegion(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n    }, jsonReq);\n  });\n  return _handleSMSMFAChallenge.apply(this, arguments);\n}\nfunction handleSoftwareTokenMFAChallenge(_x5) {\n  return _handleSoftwareTokenMFAChallenge.apply(this, arguments);\n}\nfunction _handleSoftwareTokenMFAChallenge() {\n  _handleSoftwareTokenMFAChallenge = _asyncToGenerator(function* ({\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    config\n  }) {\n    const {\n      userPoolId,\n      userPoolClientId\n    } = config;\n    const challengeResponses = {\n      USERNAME: username,\n      SOFTWARE_TOKEN_MFA_CODE: challengeResponse\n    };\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReq = {\n      ChallengeName: 'SOFTWARE_TOKEN_MFA',\n      ChallengeResponses: challengeResponses,\n      Session: session,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId,\n      UserContextData\n    };\n    return respondToAuthChallenge({\n      region: getRegion(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n    }, jsonReq);\n  });\n  return _handleSoftwareTokenMFAChallenge.apply(this, arguments);\n}\nfunction handleCompleteNewPasswordChallenge(_x6) {\n  return _handleCompleteNewPasswordChallenge.apply(this, arguments);\n}\nfunction _handleCompleteNewPasswordChallenge() {\n  _handleCompleteNewPasswordChallenge = _asyncToGenerator(function* ({\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    requiredAttributes,\n    config\n  }) {\n    const {\n      userPoolId,\n      userPoolClientId\n    } = config;\n    const challengeResponses = {\n      ...createAttributes(requiredAttributes),\n      NEW_PASSWORD: challengeResponse,\n      USERNAME: username\n    };\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReq = {\n      ChallengeName: 'NEW_PASSWORD_REQUIRED',\n      ChallengeResponses: challengeResponses,\n      ClientMetadata: clientMetadata,\n      Session: session,\n      ClientId: userPoolClientId,\n      UserContextData\n    };\n    return respondToAuthChallenge({\n      region: getRegion(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n    }, jsonReq);\n  });\n  return _handleCompleteNewPasswordChallenge.apply(this, arguments);\n}\nfunction handleUserPasswordAuthFlow(_x7, _x8, _x9, _x10, _x11) {\n  return _handleUserPasswordAuthFlow.apply(this, arguments);\n}\nfunction _handleUserPasswordAuthFlow() {\n  _handleUserPasswordAuthFlow = _asyncToGenerator(function* (username, password, clientMetadata, config, tokenOrchestrator) {\n    const {\n      userPoolClientId,\n      userPoolId\n    } = config;\n    const authParameters = {\n      USERNAME: username,\n      PASSWORD: password\n    };\n    const deviceMetadata = yield tokenOrchestrator.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n      authParameters.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReq = {\n      AuthFlow: 'USER_PASSWORD_AUTH',\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId,\n      UserContextData\n    };\n    const response = yield initiateAuth({\n      region: getRegion(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n    }, jsonReq);\n    const activeUsername = response.ChallengeParameters?.USERNAME ?? response.ChallengeParameters?.USER_ID_FOR_SRP ?? username;\n    setActiveSignInUsername(activeUsername);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH') return handleDeviceSRPAuth({\n      username: activeUsername,\n      config,\n      clientMetadata,\n      session: response.Session,\n      tokenOrchestrator\n    });\n    return response;\n  });\n  return _handleUserPasswordAuthFlow.apply(this, arguments);\n}\nfunction handleUserSRPAuthFlow(_x12, _x13, _x14, _x15, _x16) {\n  return _handleUserSRPAuthFlow.apply(this, arguments);\n}\nfunction _handleUserSRPAuthFlow() {\n  _handleUserSRPAuthFlow = _asyncToGenerator(function* (username, password, clientMetadata, config, tokenOrchestrator) {\n    const {\n      userPoolId,\n      userPoolClientId\n    } = config;\n    const userPoolName = userPoolId?.split('_')[1] || '';\n    const authenticationHelper = yield getAuthenticationHelper(userPoolName);\n    const authParameters = {\n      USERNAME: username,\n      SRP_A: authenticationHelper.A.toString(16)\n    };\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReq = {\n      AuthFlow: 'USER_SRP_AUTH',\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId,\n      UserContextData\n    };\n    const resp = yield initiateAuth({\n      region: getRegion(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n    }, jsonReq);\n    const {\n      ChallengeParameters: challengeParameters,\n      Session: session\n    } = resp;\n    const activeUsername = challengeParameters?.USERNAME ?? username;\n    setActiveSignInUsername(activeUsername);\n    return retryOnResourceNotFoundException(handlePasswordVerifierChallenge, [password, challengeParameters, clientMetadata, session, authenticationHelper, config, tokenOrchestrator], activeUsername, tokenOrchestrator);\n  });\n  return _handleUserSRPAuthFlow.apply(this, arguments);\n}\nfunction handleCustomAuthFlowWithoutSRP(_x17, _x18, _x19, _x20) {\n  return _handleCustomAuthFlowWithoutSRP.apply(this, arguments);\n}\nfunction _handleCustomAuthFlowWithoutSRP() {\n  _handleCustomAuthFlowWithoutSRP = _asyncToGenerator(function* (username, clientMetadata, config, tokenOrchestrator) {\n    const {\n      userPoolClientId,\n      userPoolId\n    } = config;\n    const authParameters = {\n      USERNAME: username\n    };\n    const deviceMetadata = yield tokenOrchestrator.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n      authParameters.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReq = {\n      AuthFlow: 'CUSTOM_AUTH',\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId,\n      UserContextData\n    };\n    const response = yield initiateAuth({\n      region: getRegion(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n    }, jsonReq);\n    const activeUsername = response.ChallengeParameters?.USERNAME ?? username;\n    setActiveSignInUsername(activeUsername);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH') return handleDeviceSRPAuth({\n      username: activeUsername,\n      config,\n      clientMetadata,\n      session: response.Session,\n      tokenOrchestrator\n    });\n    return response;\n  });\n  return _handleCustomAuthFlowWithoutSRP.apply(this, arguments);\n}\nfunction handleCustomSRPAuthFlow(_x21, _x22, _x23, _x24, _x25) {\n  return _handleCustomSRPAuthFlow.apply(this, arguments);\n}\nfunction _handleCustomSRPAuthFlow() {\n  _handleCustomSRPAuthFlow = _asyncToGenerator(function* (username, password, clientMetadata, config, tokenOrchestrator) {\n    assertTokenProviderConfig(config);\n    const {\n      userPoolId,\n      userPoolClientId\n    } = config;\n    const userPoolName = userPoolId?.split('_')[1] || '';\n    const authenticationHelper = yield getAuthenticationHelper(userPoolName);\n    const authParameters = {\n      USERNAME: username,\n      SRP_A: authenticationHelper.A.toString(16),\n      CHALLENGE_NAME: 'SRP_A'\n    };\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReq = {\n      AuthFlow: 'CUSTOM_AUTH',\n      AuthParameters: authParameters,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId,\n      UserContextData\n    };\n    const {\n      ChallengeParameters: challengeParameters,\n      Session: session\n    } = yield initiateAuth({\n      region: getRegion(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n    }, jsonReq);\n    const activeUsername = challengeParameters?.USERNAME ?? username;\n    setActiveSignInUsername(activeUsername);\n    return retryOnResourceNotFoundException(handlePasswordVerifierChallenge, [password, challengeParameters, clientMetadata, session, authenticationHelper, config, tokenOrchestrator], activeUsername, tokenOrchestrator);\n  });\n  return _handleCustomSRPAuthFlow.apply(this, arguments);\n}\nfunction handleDeviceSRPAuth(_x26) {\n  return _handleDeviceSRPAuth.apply(this, arguments);\n}\nfunction _handleDeviceSRPAuth() {\n  _handleDeviceSRPAuth = _asyncToGenerator(function* ({\n    username,\n    config,\n    clientMetadata,\n    session,\n    tokenOrchestrator\n  }) {\n    const {\n      userPoolId\n    } = config;\n    const clientId = config.userPoolClientId;\n    const deviceMetadata = yield tokenOrchestrator?.getDeviceMetadata(username);\n    assertDeviceMetadata(deviceMetadata);\n    const authenticationHelper = yield getAuthenticationHelper(deviceMetadata.deviceGroupKey);\n    const challengeResponses = {\n      USERNAME: username,\n      SRP_A: authenticationHelper.A.toString(16),\n      DEVICE_KEY: deviceMetadata.deviceKey\n    };\n    const jsonReqResponseChallenge = {\n      ChallengeName: 'DEVICE_SRP_AUTH',\n      ClientId: clientId,\n      ChallengeResponses: challengeResponses,\n      ClientMetadata: clientMetadata,\n      Session: session\n    };\n    const {\n      ChallengeParameters: respondedChallengeParameters,\n      Session\n    } = yield respondToAuthChallenge({\n      region: getRegion(userPoolId)\n    }, jsonReqResponseChallenge);\n    return handleDevicePasswordVerifier(username, respondedChallengeParameters, clientMetadata, Session, authenticationHelper, config, tokenOrchestrator);\n  });\n  return _handleDeviceSRPAuth.apply(this, arguments);\n}\nfunction handleDevicePasswordVerifier(_x27, _x28, _x29, _x30, _x31, _x32, _x33) {\n  return _handleDevicePasswordVerifier.apply(this, arguments);\n}\nfunction _handleDevicePasswordVerifier() {\n  _handleDevicePasswordVerifier = _asyncToGenerator(function* (username, challengeParameters, clientMetadata, session, authenticationHelper, {\n    userPoolId,\n    userPoolClientId\n  }, tokenOrchestrator) {\n    const deviceMetadata = yield tokenOrchestrator?.getDeviceMetadata(username);\n    assertDeviceMetadata(deviceMetadata);\n    const serverBValue = new BigInteger(challengeParameters?.SRP_B, 16);\n    const salt = new BigInteger(challengeParameters?.SALT, 16);\n    const {\n      deviceKey\n    } = deviceMetadata;\n    const {\n      deviceGroupKey\n    } = deviceMetadata;\n    const hkdf = yield authenticationHelper.getPasswordAuthenticationKey({\n      username: deviceMetadata.deviceKey,\n      password: deviceMetadata.randomPassword,\n      serverBValue,\n      salt\n    });\n    const dateNow = getNowString();\n    const challengeResponses = {\n      USERNAME: challengeParameters?.USERNAME ?? username,\n      PASSWORD_CLAIM_SECRET_BLOCK: challengeParameters?.SECRET_BLOCK,\n      TIMESTAMP: dateNow,\n      PASSWORD_CLAIM_SIGNATURE: getSignatureString({\n        username: deviceKey,\n        userPoolName: deviceGroupKey,\n        challengeParameters,\n        dateNow,\n        hkdf\n      }),\n      DEVICE_KEY: deviceKey\n    };\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReqResponseChallenge = {\n      ChallengeName: 'DEVICE_PASSWORD_VERIFIER',\n      ClientId: userPoolClientId,\n      ChallengeResponses: challengeResponses,\n      Session: session,\n      ClientMetadata: clientMetadata,\n      UserContextData\n    };\n    return respondToAuthChallenge({\n      region: getRegion(userPoolId)\n    }, jsonReqResponseChallenge);\n  });\n  return _handleDevicePasswordVerifier.apply(this, arguments);\n}\nfunction handlePasswordVerifierChallenge(_x34, _x35, _x36, _x37, _x38, _x39, _x40) {\n  return _handlePasswordVerifierChallenge.apply(this, arguments);\n}\nfunction _handlePasswordVerifierChallenge() {\n  _handlePasswordVerifierChallenge = _asyncToGenerator(function* (password, challengeParameters, clientMetadata, session, authenticationHelper, config, tokenOrchestrator) {\n    const {\n      userPoolId,\n      userPoolClientId\n    } = config;\n    const userPoolName = userPoolId?.split('_')[1] || '';\n    const serverBValue = new BigInteger(challengeParameters?.SRP_B, 16);\n    const salt = new BigInteger(challengeParameters?.SALT, 16);\n    const username = challengeParameters?.USER_ID_FOR_SRP;\n    if (!username) throw new AuthError({\n      name: 'EmptyUserIdForSRPException',\n      message: 'USER_ID_FOR_SRP was not found in challengeParameters'\n    });\n    const hkdf = yield authenticationHelper.getPasswordAuthenticationKey({\n      username,\n      password,\n      serverBValue,\n      salt\n    });\n    const dateNow = getNowString();\n    const challengeResponses = {\n      USERNAME: username,\n      PASSWORD_CLAIM_SECRET_BLOCK: challengeParameters?.SECRET_BLOCK,\n      TIMESTAMP: dateNow,\n      PASSWORD_CLAIM_SIGNATURE: getSignatureString({\n        username,\n        userPoolName,\n        challengeParameters,\n        dateNow,\n        hkdf\n      })\n    };\n    const deviceMetadata = yield tokenOrchestrator.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n      challengeResponses.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n      username,\n      userPoolId,\n      userPoolClientId\n    });\n    const jsonReqResponseChallenge = {\n      ChallengeName: 'PASSWORD_VERIFIER',\n      ChallengeResponses: challengeResponses,\n      ClientMetadata: clientMetadata,\n      Session: session,\n      ClientId: userPoolClientId,\n      UserContextData\n    };\n    const response = yield respondToAuthChallenge({\n      region: getRegion(userPoolId)\n    }, jsonReqResponseChallenge);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH') return handleDeviceSRPAuth({\n      username,\n      config,\n      clientMetadata,\n      session: response.Session,\n      tokenOrchestrator\n    });\n    return response;\n  });\n  return _handlePasswordVerifierChallenge.apply(this, arguments);\n}\nfunction getSignInResult(_x41) {\n  return _getSignInResult.apply(this, arguments);\n}\nfunction _getSignInResult() {\n  _getSignInResult = _asyncToGenerator(function* (params) {\n    const {\n      challengeName,\n      challengeParameters\n    } = params;\n    const authConfig = Amplify.getConfig().Auth?.Cognito;\n    assertTokenProviderConfig(authConfig);\n    switch (challengeName) {\n      case 'CUSTOM_CHALLENGE':\n        return {\n          isSignedIn: false,\n          nextStep: {\n            signInStep: 'CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE',\n            additionalInfo: challengeParameters\n          }\n        };\n      case 'MFA_SETUP':\n        {\n          const {\n            signInSession,\n            username\n          } = signInStore.getState();\n          if (!isMFATypeEnabled(challengeParameters, 'TOTP')) throw new AuthError({\n            name: AuthErrorCodes.SignInException,\n            message: `Cannot initiate MFA setup from available types: ${getMFATypes(parseMFATypes(challengeParameters.MFAS_CAN_SETUP))}`\n          });\n          const {\n            Session,\n            SecretCode: secretCode\n          } = yield associateSoftwareToken({\n            region: getRegion(authConfig.userPoolId)\n          }, {\n            Session: signInSession\n          });\n          signInStore.dispatch({\n            type: 'SET_SIGN_IN_SESSION',\n            value: Session\n          });\n          return {\n            isSignedIn: false,\n            nextStep: {\n              signInStep: 'CONTINUE_SIGN_IN_WITH_TOTP_SETUP',\n              totpSetupDetails: getTOTPSetupDetails(secretCode, username)\n            }\n          };\n        }\n      case 'NEW_PASSWORD_REQUIRED':\n        return {\n          isSignedIn: false,\n          nextStep: {\n            signInStep: 'CONFIRM_SIGN_IN_WITH_NEW_PASSWORD_REQUIRED',\n            missingAttributes: parseAttributes(challengeParameters.requiredAttributes)\n          }\n        };\n      case 'SELECT_MFA_TYPE':\n        return {\n          isSignedIn: false,\n          nextStep: {\n            signInStep: 'CONTINUE_SIGN_IN_WITH_MFA_SELECTION',\n            allowedMFATypes: getMFATypes(parseMFATypes(challengeParameters.MFAS_CAN_CHOOSE))\n          }\n        };\n      case 'SMS_MFA':\n        return {\n          isSignedIn: false,\n          nextStep: {\n            signInStep: 'CONFIRM_SIGN_IN_WITH_SMS_CODE',\n            codeDeliveryDetails: {\n              deliveryMedium: challengeParameters.CODE_DELIVERY_DELIVERY_MEDIUM,\n              destination: challengeParameters.CODE_DELIVERY_DESTINATION\n            }\n          }\n        };\n      case 'SOFTWARE_TOKEN_MFA':\n        return {\n          isSignedIn: false,\n          nextStep: {\n            signInStep: 'CONFIRM_SIGN_IN_WITH_TOTP_CODE'\n          }\n        };\n    }\n    // TODO: remove this error message for production apps\n    throw new AuthError({\n      name: AuthErrorCodes.SignInException,\n      message: 'An error occurred during the sign in process. ' + `${challengeName} challengeName returned by the underlying service was not addressed.`\n    });\n  });\n  return _getSignInResult.apply(this, arguments);\n}\nfunction getTOTPSetupDetails(secretCode, username) {\n  return {\n    sharedSecret: secretCode,\n    getSetupUri: (appName, accountName) => {\n      const totpUri = `otpauth://totp/${appName}:${accountName ?? username}?secret=${secretCode}&issuer=${appName}`;\n      return new AmplifyUrl(totpUri);\n    }\n  };\n}\nfunction getSignInResultFromError(errorName) {\n  if (errorName === InitiateAuthException.PasswordResetRequiredException) {\n    return {\n      isSignedIn: false,\n      nextStep: {\n        signInStep: 'RESET_PASSWORD'\n      }\n    };\n  } else if (errorName === InitiateAuthException.UserNotConfirmedException) {\n    return {\n      isSignedIn: false,\n      nextStep: {\n        signInStep: 'CONFIRM_SIGN_UP'\n      }\n    };\n  }\n}\nfunction parseAttributes(attributes) {\n  if (!attributes) return [];\n  const parsedAttributes = JSON.parse(attributes).map(att => att.includes(USER_ATTRIBUTES) ? att.replace(USER_ATTRIBUTES, '') : att);\n  return parsedAttributes;\n}\nfunction createAttributes(attributes) {\n  if (!attributes) return {};\n  const newAttributes = {};\n  Object.entries(attributes).forEach(([key, value]) => {\n    if (value) newAttributes[`${USER_ATTRIBUTES}${key}`] = value;\n  });\n  return newAttributes;\n}\nfunction handleChallengeName(_x42, _x43, _x44, _x45, _x46, _x47, _x48, _x49) {\n  return _handleChallengeName.apply(this, arguments);\n}\nfunction _handleChallengeName() {\n  _handleChallengeName = _asyncToGenerator(function* (username, challengeName, session, challengeResponse, config, tokenOrchestrator, clientMetadata, options) {\n    const userAttributes = options?.userAttributes;\n    const deviceName = options?.friendlyDeviceName;\n    switch (challengeName) {\n      case 'SMS_MFA':\n        return handleSMSMFAChallenge({\n          challengeResponse,\n          clientMetadata,\n          session,\n          username,\n          config\n        });\n      case 'SELECT_MFA_TYPE':\n        return handleSelectMFATypeChallenge({\n          challengeResponse,\n          clientMetadata,\n          session,\n          username,\n          config\n        });\n      case 'MFA_SETUP':\n        return handleMFASetupChallenge({\n          challengeResponse,\n          clientMetadata,\n          session,\n          username,\n          deviceName,\n          config\n        });\n      case 'NEW_PASSWORD_REQUIRED':\n        return handleCompleteNewPasswordChallenge({\n          challengeResponse,\n          clientMetadata,\n          session,\n          username,\n          requiredAttributes: userAttributes,\n          config\n        });\n      case 'CUSTOM_CHALLENGE':\n        return retryOnResourceNotFoundException(handleCustomChallenge, [{\n          challengeResponse,\n          clientMetadata,\n          session,\n          username,\n          config,\n          tokenOrchestrator\n        }], username, tokenOrchestrator);\n      case 'SOFTWARE_TOKEN_MFA':\n        return handleSoftwareTokenMFAChallenge({\n          challengeResponse,\n          clientMetadata,\n          session,\n          username,\n          config\n        });\n    }\n    // TODO: remove this error message for production apps\n    throw new AuthError({\n      name: AuthErrorCodes.SignInException,\n      message: `An error occurred during the sign in process. \n\t\t${challengeName} challengeName returned by the underlying service was not addressed.`\n    });\n  });\n  return _handleChallengeName.apply(this, arguments);\n}\nfunction mapMfaType(mfa) {\n  let mfaType = 'SMS_MFA';\n  if (mfa === 'TOTP') mfaType = 'SOFTWARE_TOKEN_MFA';\n  return mfaType;\n}\nfunction getMFAType(type) {\n  if (type === 'SMS_MFA') return 'SMS';\n  if (type === 'SOFTWARE_TOKEN_MFA') return 'TOTP';\n  // TODO: log warning for unknown MFA type\n}\n\nfunction getMFATypes(types) {\n  if (!types) return undefined;\n  return types.map(getMFAType).filter(Boolean);\n}\nfunction parseMFATypes(mfa) {\n  if (!mfa) return [];\n  return JSON.parse(mfa);\n}\nfunction isMFATypeEnabled(challengeParams, mfaType) {\n  const {\n    MFAS_CAN_SETUP\n  } = challengeParams;\n  const mfaTypes = getMFATypes(parseMFATypes(MFAS_CAN_SETUP));\n  if (!mfaTypes) return false;\n  return mfaTypes.includes(mfaType);\n}\nfunction assertUserNotAuthenticated() {\n  return _assertUserNotAuthenticated.apply(this, arguments);\n}\n/**\n * This function is used to kick off the device management flow.\n *\n * If an error is thrown while generating a hash device or calling the `ConfirmDevice`\n * client, then this API will ignore the error and return undefined. Otherwise the authentication\n * flow will not complete and the user won't be able to be signed in.\n *\n * @returns DeviceMetadata | undefined\n */\nfunction _assertUserNotAuthenticated() {\n  _assertUserNotAuthenticated = _asyncToGenerator(function* () {\n    let authUser;\n    try {\n      authUser = yield getCurrentUser();\n    } catch (error) {}\n    if (authUser && authUser.userId && authUser.username) {\n      throw new AuthError({\n        name: USER_ALREADY_AUTHENTICATED_EXCEPTION,\n        message: 'There is already a signed in user.',\n        recoverySuggestion: 'Call signOut before calling signIn again.'\n      });\n    }\n  });\n  return _assertUserNotAuthenticated.apply(this, arguments);\n}\nfunction getNewDeviceMetatada(_x50, _x51, _x52) {\n  return _getNewDeviceMetatada.apply(this, arguments);\n}\n/**\n * It will retry the function if the error is a `ResourceNotFoundException` and\n * will clean the device keys stored in the storage mechanism.\n *\n */\nfunction _getNewDeviceMetatada() {\n  _getNewDeviceMetatada = _asyncToGenerator(function* (userPoolId, newDeviceMetadata, accessToken) {\n    if (!newDeviceMetadata) return undefined;\n    const userPoolName = userPoolId.split('_')[1] || '';\n    const authenticationHelper = yield getAuthenticationHelper(userPoolName);\n    const deviceKey = newDeviceMetadata?.DeviceKey;\n    const deviceGroupKey = newDeviceMetadata?.DeviceGroupKey;\n    try {\n      yield authenticationHelper.generateHashDevice(deviceGroupKey ?? '', deviceKey ?? '');\n    } catch (errGenHash) {\n      // TODO: log error here\n      return undefined;\n    }\n    const deviceSecretVerifierConfig = {\n      Salt: base64Encoder.convert(getBytesFromHex(authenticationHelper.getSaltToHashDevices())),\n      PasswordVerifier: base64Encoder.convert(getBytesFromHex(authenticationHelper.getVerifierDevices()))\n    };\n    const randomPassword = authenticationHelper.getRandomPassword();\n    try {\n      yield confirmDevice({\n        region: getRegion(userPoolId)\n      }, {\n        AccessToken: accessToken,\n        DeviceKey: newDeviceMetadata?.DeviceKey,\n        DeviceSecretVerifierConfig: deviceSecretVerifierConfig\n      });\n      return {\n        deviceKey,\n        deviceGroupKey,\n        randomPassword\n      };\n    } catch (error) {\n      // TODO: log error here\n      return undefined;\n    }\n  });\n  return _getNewDeviceMetatada.apply(this, arguments);\n}\nfunction retryOnResourceNotFoundException(_x53, _x54, _x55, _x56) {\n  return _retryOnResourceNotFoundException.apply(this, arguments);\n}\nfunction _retryOnResourceNotFoundException() {\n  _retryOnResourceNotFoundException = _asyncToGenerator(function* (func, args, username, tokenOrchestrator) {\n    try {\n      return yield func(...args);\n    } catch (error) {\n      if (error instanceof AuthError && error.name === 'ResourceNotFoundException' && error.message.includes('Device does not exist.')) {\n        yield tokenOrchestrator.clearDeviceMetadata(username);\n        return func(...args);\n      }\n      throw error;\n    }\n  });\n  return _retryOnResourceNotFoundException.apply(this, arguments);\n}\nfunction setActiveSignInUsername(username) {\n  const {\n    dispatch\n  } = signInStore;\n  dispatch({\n    type: 'SET_USERNAME',\n    value: username\n  });\n}\nfunction getActiveSignInUsername(username) {\n  const state = signInStore.getState();\n  return state.username ?? username;\n}\nexport { assertUserNotAuthenticated, createAttributes, getActiveSignInUsername, getMFAType, getMFATypes, getNewDeviceMetatada, getSignInResult, getSignInResultFromError, getTOTPSetupDetails, handleChallengeName, handleCompleteNewPasswordChallenge, handleCustomAuthFlowWithoutSRP, handleCustomChallenge, handleCustomSRPAuthFlow, handleMFASetupChallenge, handlePasswordVerifierChallenge, handleSMSMFAChallenge, handleSelectMFATypeChallenge, handleSoftwareTokenMFAChallenge, handleUserPasswordAuthFlow, handleUserSRPAuthFlow, isMFATypeEnabled, mapMfaType, parseAttributes, parseMFATypes, retryOnResourceNotFoundException, setActiveSignInUsername };\n//# sourceMappingURL=signInHelpers.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}